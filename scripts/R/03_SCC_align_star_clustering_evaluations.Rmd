---
title: "Differential expression in LBD samples"
author: "Kimberly Olney, Ph.D."
date: "09/30/2022"
output:
  html_document:
    df_print: paged
  pdf_document: default
params:
  args: myarg
---
Samples have already been sex checked and realigned to the SCC reference. 
# Setup
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```
install.packages("devtools")
install lasso first, then DEGrport
install.packages("https://cran.r-project.org/src/contrib/Archive/lasso2/lasso2_1.2-22.tar.gz", repos = NULL)
devtools::install_github("lpantano/DEGreport")
library(DEGreport)
```{r libraries, message=FALSE, warning=FALSE}
library(rmarkdown)
library(BiocParallel)  
library(dplyr) 
library(edgeR) 
library(limma)  
library(ggrepel) 
library(ggplot2) 
library(gplots)  
library(grDevices) 
require(philentropy)  
library(rtracklayer)  
library(stringr)  
require(variancePartition)  
library(reshape)  
library(Glimma)
library(plyr)
library(corrplot)
library(ggpubr)
library(tidyverse)
library(caret)
library(glmnet)
library(vroom)
library(matrixStats)
library("data.table")
library(DESeq2)
library(DEGreport)
library(dittoSeq)
```
# Save pdf function
```{r}
saveToPDF <- function(...) {
    d = dev.copy(pdf,...)
    dev.off(d)
}
```
# User defined variables
```{r set_variables}
source(here::here("scripts/R", "file_paths_and_colours.R"))

directory <- c("pass1/")
condition <- c("All_samples")

myContrasts <- c("LBDvsControl = LBD - CONTROL",
  "LBDvsAD = LBD - AD",
  "LBDvsPA = LBD - PA",
  "ADvsControl = AD - CONTROL", 
  "PAvsControl = PA - CONTROL",
  "ADvsPA = AD - PA")
tool = c("star")
typeOfCount <-  c(".bamReadsPerGene.out.tab")
```

# Read data
### metadata
```{r read_data}
# read in metadata
# the expanded metadata contains inferred sex, RIN, and WGS sample IDs
metadata <- vroom(paste0(pathToRawData, "RNA_metadata.tsv"))
# remove duplicates if any 
metadata <- metadata[!duplicated(metadata[,c('RNA.config.ID')]),]
# rename columns for easier plotting 
# names(metadata)[names(metadata) == "TYPE"] <- "Disease group"
metadata <- metadata %>%
  mutate(across('TYPE', str_replace, 'CONTROL - AD', 'AD'))
metadata <- metadata %>%
  mutate(across('TYPE', str_replace, 'CONTROL - PA', 'PA'))
metadata$TYPE <- factor(metadata$TYPE, levels = c("CONTROL", "AD", "PA", "LBD"))


metadata <- metadata %>% mutate(sex_chr = case_when(
  startsWith(sex_inferred, "female") ~ "XX", 
  startsWith(sex_inferred, "male") ~ "XY"))

# remove rows with no inferred sex.
# No counts data for this samples because there is no RNAseq data for that individual
metadata <- metadata[!is.na(metadata$sex_inferred),]

# example of file naming:
# NA12-254_FCHCLTJDMXY_L1_STAR_XY.bamReadsPerGene.out.tab
# path to counts files
count_files <-
  file.path(paste0(
    "../../starAligned_SCC/",
    metadata$NPID,
    "_STAR_",
    metadata$sex_chr,
    typeOfCount
  ))
# add sample name to counts files
names(count_files) <- paste0(metadata$NPID)
# add sample count path information to metadata
metadata$path <- count_files
# make sure there is only unique paths
```
### create a counts matrix
```{r}
counts <- data.frame(fread(count_files[1]))[c(1, 2)]
# Loop and read the 2nd column remaining files
for (i in 2:length(count_files)) {
  counts <- cbind(counts, data.frame(fread(count_files[i]))[2])
}
```
# Star mapping metrics
```{r}
star_metrics <- data.frame(counts[counts$V1 %like% "N_", ])
star_metrics$V1 <- as.vector(star_metrics$V1)
melt_star_metrics <- reshape::melt(star_metrics, id = c("V1"))
ggplot(melt_star_metrics, aes(x = value, fill = V1)) + 
  geom_histogram(position = "identity", bins = 100) + 
  facet_grid(V1 ~ .)  + theme_bw()
```
clean up
```{r}
# clean up
remove(melt_star_metrics, 
       params, 
       star_metrics)
```
# format counts table
```{r}
# remove star metric information
counts <- counts[!grepl("N_", counts$V1),]
# set gene_id (i.e. V1) as the row name
row.names(counts) <- counts$V1
counts$V1 <- NULL
# set column names to NPID sample ID
colnames(counts) <- metadata$NPID
```
# Get gene information
```{r}
# read in annotation file
gtf.file <- paste0(pathToRef, "gencode.v38.annotation.gtf")
genes.gtf <- rtracklayer::import(gtf.file)
genes.gtf <- as.data.frame(genes.gtf)
genes.gtf <- genes.gtf[genes.gtf$type == "gene",]
table(genes.gtf$gene_type)
```
# Check inputs
```{r}
all.equal(rownames(counts), genes.gtf$gene_id)
all.equal(colnames(counts), (metadata$NPID))
```
# Create DGE object
```{r DGE_object}
# create object
dge <- DGEList(counts = counts,
               samples = metadata,
               genes = genes.gtf)

table(dge$samples$TYPE)
```

# Save R object
```{r, eval=FALSE}
saveRDS(dge, file = paste0("../../rObjects/", directory, "LBD_SCC_dge.raw.rds"))
dge <- readRDS(paste0("../../rObjects/", directory, "LBD_SCC_dge.raw.rds"))
```

# Remove mitochondrial genes & keep only protein coding genes
```{r MT_genes}
dim(dge)
removeMT <- dge$genes$seqnames != "chrM"  # true when NOT MT
dge <- dge[removeMT,,keep.lib.sizes = FALSE]
keepProtein <- dge$genes$gene_type == "protein_coding"
dge <- dge[keepProtein,,keep.lib.sizes = FALSE]
dim(dge)
```
# Raw MDS
convert counts to cpm and lcpm
set colors and get data
```{r cpm, warning=FALSE}
lcpm <- edgeR::cpm(dge$counts, log = TRUE)
cpm <- edgeR::cpm(dge$counts, log = FALSE)
dge$samples$sex_inferred <- as.factor(dge$samples$sex_inferred)
sex_colors <- c(SexColors)[dge$samples$sex_inferred]

dge$samples$LBD.type <- as.factor(dge$samples$LBD.type)
LBD.type_colors <- c(colorbindColors)[dge$samples$LBD.type]

dge$samples$LBD.type <- as.factor(dge$samples$LBD.type)
LBD.type_colors <- c(colorbindColors)[dge$samples$LBD.type]

dge$samples$MF.LB <- as.factor(dge$samples$MF.LB)
MF.LB_colors <- c(colorbindColors)[dge$samples$MF.LB]
```


```{r}
par(bg = 'white')

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))

path <- paste0("../../results/", directory, tool, "/MDS/", 
               condition,"_MDS_label_sex_dim1&2")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(2,3), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))
path <- paste0("../../results/", directory, tool, "/MDS/", 
               condition,"_MDS_label_sex_dim2&3")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```

# Filtering and RIN check
The filterByExpr() function in the edgeR package determines which genes have a 
great enough count value to keep.  We will filter by group.  This means at least 
6 samples (6 is the smallest group sample size) must express a minimum count of 
10 (in cpm, default value).
```{r}
# first filter by expression and normalize the data
keep.expr <- filterByExpr(dge, group = dge$samples$TYPE)
dim(dge)
dge.filtered <- dge[keep.expr, , keep.lib.sizes = FALSE]

dim(dge.filtered)
table(dge.filtered$genes$gene_type)

# Now, normalization by the method of trimmed mean of M-values (TMM)
dge.filtered.norm <- calcNormFactors(dge.filtered, method = "TMM")

# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = T)
nsamples <- ncol(dge.filtered.norm)
# Create a vector named "new_order" containing the desired order
boxplot(log2cpm.norm, 
        main="Filtered normalized lcpm data", 
        xlab="RIN", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE)
axis(2)
axis(1,at=1:nsamples,labels=(dge.filtered.norm$samples$RIN),las=2,cex.axis=0.8)

path <- paste0("../../results/",directory, tool, "/library/boxplot_RIN")
saveToPDF(paste0(path, ".pdf"), width = 35, height = 6)
```

# RIN check with replicates summed
```{r}
# check if there is correlation between RIN and library size
box <- dge.filtered.norm$samples

cor(box$RIN, box$lib.size, method = c("pearson", "kendall", "spearman"))
cor.test(box$RIN, box$lib.size, method=c("pearson", "kendall", "spearman"))

# is the data normally distrubited 
ggqqplot(box$lib.size, ylab = "library size")
# wt
ggqqplot(box$RIN, ylab = "RIN")
res <- cor.test(box$lib.size, box$RIN, 
                method = "pearson")
res

ggscatter(box, x = "RIN", y = "lib.size", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          ylab = "library size", xlab = "RIN value") 

path <- paste0("../../results/", directory, tool, "/library/LBD_corr_RIN_lib_size")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
```
```{r}
metadata_continuous <-
  data.frame(
    dge.filtered.norm$samples$RIN,
    dge.filtered.norm$samples$norm.factors,
    dge.filtered.norm$samples$lib.size
  )

lib_info <- dge.filtered.norm$samples
column_variables <- c("RIN", "norm.factors", "lib.size")
my_comparisons <-
  list(
    c("CONTROL", "AD"),
    c("CONTROL", "PA"),
    c("CONTROL", "LBD"),
    c("AD", "PA"),
    c("AD", "LBD"),
    c("PA", "LBD")
  )

violin_plot_fun <- function(i, j) {
  ggplot(dge.filtered.norm$samples, aes(group, i)) +
    geom_violin() +
    geom_boxplot(width = 0.1) +
    geom_jitter(shape = 16, position = position_jitter(0.2)) +
    theme_bw() +
    ggtitle(j) +
    xlab("All samples") +
    ylab(j) +
    theme(legend.position = "none")
}
violin_plots <-
  Map(violin_plot_fun, i = metadata_continuous, j = column_variables)
violin_plots

plotnames = imap(
  violin_plots,
  ~ paste0(
    "../../results/",
    directory,
    tool,
    "/variance/All_samples_",
    .y,
    ".pdf"
  )
) %>%
  flatten()
plotnames
walk2(plotnames,
      violin_plots,
      ~ ggsave(
        filename = .x,
        plot = .y,
        height = 4,
        width = 5.5
      ))


violin_plot_fun <- function(i, j) {
  ggplot(dge.filtered.norm$samples,
         aes(TYPE, i, fill = dge.filtered.norm$samples$TYPE)) +
    geom_violin() +
    geom_boxplot(width = 0.1) +
    geom_jitter(shape = 16, position = position_jitter(0.2)) +
    theme_bw() +
    ggtitle(j) +
    xlab("Disease group") +
    ylab(j) +
    stat_compare_means(comparisons = my_comparisons) +
    scale_fill_manual(values = TypeColors) +
    theme(legend.position = "none")
}
violin_plots <-
  Map(violin_plot_fun, i = metadata_continuous, j = column_variables)
violin_plots

plotnames = imap(
  violin_plots,
  ~ paste0(
    "../../results/",
    directory,
    tool,
    "/variance/By_TYPE_",
    .y,
    ".pdf"
  )
) %>%
  flatten()
plotnames
walk2(plotnames,
      violin_plots,
      ~ ggsave(
        filename = .x,
        plot = .y,
        height = 4,
        width = 5.5
      ))

outliers <- boxplot(dge.filtered.norm$samples$lib.size,plot=FALSE)$out
outliers_NPID <- dge.filtered.norm$samples[dge.filtered.norm$samples$lib.size %in% outliers,]
```

# Raw MDS
```{r}
par(bg = 'white')

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge.filtered.norm$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))

path <- paste0("../../results/",directory, tool, "/MDS/", 
               condition,"_gene_MDS_label_sex_dim1&2")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```


```{r TMM_normalize}
# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
```

# Density plot
Density plots of log-intensity distribution of each library can be superposed 
on a single graph for a better comparison between libraries and for 
identification of libraries with weird distribution. 
```{r density_plots}
# set graphical parameter
par(mfrow = c(1,3))

# Normalize data for library size and expression intesntiy
log2cpm.tech <- edgeR::cpm(dge, log = TRUE)
log2cpm.filtered <- edgeR::cpm(dge.filtered, log = TRUE)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = TRUE)

# set colors
colors <- colorbindColors
nsamples <- ncol(dge)

# First, plot the first column of the log2cpm.tech density
plot(density(log2cpm.tech[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "A. Raw", xlab = expression('Log'[2]~CPM))

# For each sample plot the lcpm density
for (i in 2:nsamples){
  den <- density(log2cpm.tech[,i]) #subset each column
  lines(den$x, den$y, col = colors[i], lwd = 2) 
}

# Second, plot log2cpm.filtered
plot(density(log2cpm.filtered[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "B. Filtered", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.filtered[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# Third, plot log2cpm.norm
plot(density(log2cpm.norm[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "C. Normalized", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.norm[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# save
path <- paste0("../../results/", directory, tool, "/library/LBD_gene_density")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```


```{r}
remove(box,
       res)
```

```{r}
remove(
       dge, 
       dge.filtered,
       lcpm,
       log2cpm.filtered,
       log2cpm.norm,
       log2cpm.tech)
```

# Save R object
```{r}
saveRDS(dge.filtered.norm, file = paste0("../../rObjects/", directory, "dge.filtered.norm.rds"))
dge.filtered.norm <- readRDS(paste0("../../rObjects/", directory, "dge.filtered.norm.rds"))
```
# Variance Parition
```{r}

#keepLBD <- dge.filtered.norm$samples$TYPE == "LBD"
#LBD_dge <- dge.filtered.norm[,keepLBD,keep.lib.sizes = FALSE]
#dim(LBD_dge)

counts <- dge.filtered.norm$counts
info <- dge.filtered.norm$samples$CWOW.Category
genes <- dge.filtered.norm$genes

formula <- ~ Age + (1|TYPE) + (1|APOE) + (1|sex_inferred)

# fit regression model for the first gene
form_test <- counts[1,] ~ Age + (1|APOE) + (1|TYPE) + (1|sex_inferred) + VaD +MF.NFT + MF.Amyloid + MF.SP + MF.Tau + (1|MF.LB) + Brain.wt + RIN + PMI + (1|AD.subtype) + (1|PathDx)+ (1|LBD.type) + lib.size + norm.factors + (1|Race)

form_test <- counts[1,] ~ Age + RIN + PMI + Brain.wt + (1|TYPE) + (1|sex_inferred) + (1|CWOW.Category)
  
  #(1|APOE) + (1|TYPE) + (1|sex_inferred) + VaD +MF.NFT + MF.Amyloid + MF.SP + MF.Tau + (1|MF.LB) + Brain.wt + RIN + PMI + (1|AD.subtype) + (1|PathDx)+ (1|LBD.type) + lib.size + norm.factors + (1|Race)

#form <- ~ TYPE + PathDx + AD.subtype + LBD.type + CDLB + Braak.NFT + Thal.amyloid + MF.SP + MF.NFT + MF.LB + Cing.LB + MF.Amyloid + MF.Tau + Cing.Synuclein + CWOW.Category + VaD  + TDP.type + Brain.wt + ClinicalDx + FHx + Duration + Sex + Age + Race + PMI + APOE + MAPT + GRN + TMEM106b + RIN + Total.RNA.ng 

fit <- lmer(form_test, info, REML=FALSE )
fit <- lmer(form_test, info, REML=FALSE )

# extract variance statistics
# Compute fraction of variation attributable to each variable in regression model. Also interpretable as the intra-class correlation after correcting for all other variables in the model.
calcVarPart(fit)

varPart <- fitExtractVarPartModel( counts, formula, info )
vp <- sortCols( varPart )
plotPercentBars( vp[1:10,] )
plotVarPart( vp )
head(varPart)
head(varPart$Individual)

```

```{r}
#--------------
library('variancePartition')
data(varPartData)
form <- ~ Age + (1|Individual) + (1|Tissue) + (1|Batch)
varPart <- fitExtractVarPartModel( geneExpr, form, info )
vp <- sortCols( varPart )
plotPercentBars( vp[1:10,] )
plotVarPart( vp )
head(varPart)
head(varPart$Individual)


i <- which.max( varPart$Tissue )
GE <- data.frame( Expression = geneExpr[i,], Tissue = info$Tissue)
# Figure 2a
# plot expression stratified by Tissue
plotStratify( Expression ~ Tissue, GE, main=rownames(geneExpr)[i]) #
# get gene with the highest variation across Individuals
# create data.frame with expression of gene i and Tissue
# type for each sample
i <- which.max( varPart$Individual )
GE <- data.frame( Expression = geneExpr[i,],
        Individual = info$Individual)
# Figure 2b
# plot expression stratified by Tissue
label <- paste("Individual:", format(varPart$Individual[i]*100,
        digits=3), "%")
main <- rownames(geneExpr)[i]
plotStratify(  Expression ~ Individual, GE, colorBy=NULL,
        text=label, main=main)

library('lme4')
# fit regression model for the first gene
form_test <- geneExpr[1,] ~ Age + (1|Individual) + (1|Tissue)
fit <- lmer(form_test, info, REML=FALSE )
# extract variance statistics
# Compute fraction of variation attributable to each variable in regression model. Also interpretable as the intra-class correlation after correcting for all other variables in the model.
calcVarPart(fit)
help(calcVarPart)
```

# Design matrix
```{r design_matrix}
age <- as.numeric(dge.filtered.norm$samples$Age)
dge.filtered.norm$samples$RIN[is.na(dge.filtered.norm$samples$RIN)] <- 1
RIN <- as.numeric(dge.filtered.norm$samples$RIN)
dge.filtered.norm$samples$VaD[is.na(dge.filtered.norm$samples$VaD)] <- 0
VaD <- as.factor(dge.filtered.norm$samples$VaD)

sex <- as.factor(dge.filtered.norm$samples$sex_inferred)
race <- as.factor(dge.filtered.norm$samples$Race)

group <- as.factor(dge.filtered.norm$samples$TYPE)

design <- model.matrix(~ 0 + group+ sex + RIN)
colnames(design) <- c(CONTROL, AD, PA, LBD, "sex", "RIN")
```

# Voom
```{r voom}
# voom transform counts
#v <- voomWithQualityWeights(dge.filtered.norm,
#                            design,
#                            plot = FALSE)

# no weights needed with this large sample size
v <- voom(dge.filtered.norm, design, plot=TRUE)
path <- paste0("../../results/", tool, "/voom/LBD_gene_mean_voom")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```
# PCA on all/the most variable genes
Select most variable genes based on the biological 
coefficient of variance

```{r pca, cache=TRUE}
# Voom transformed counts
voomCounts <- v$E
voomCountsMatrix <- data.matrix(voomCounts, rownames.force = NA)
# Setting the N of genes to use
ntop = length(dge.filtered.norm$genes$gene_id)
# Sorting by the coefficient of variance
means <- rowMeans(voomCountsMatrix)
Pvars <- rowVars(voomCountsMatrix)
cv2 <- Pvars / means ^ 2
select <-
  order(cv2, decreasing = TRUE)[seq_len(min(ntop, length(cv2)))]
head(select)
highly_variable_exp <- ((voomCountsMatrix)[select,])
dim(highly_variable_exp)
# Running PCA
pca_exp <- prcomp(t(highly_variable_exp), scale = F, center = T)
# scale a logical value indicating whether the variables should be scaled
# to have unit variance before the analysis takes place.
# a logical value indicating whether the variables should be shifted to be zero centered.
head(pca_exp$x)[, 1:3]
summary(pca_exp)
# Dataframe with the first 10 PCs
dim1_10 <- data.frame(pca_exp$x[, 1:10])
# Adding metadata
pcaWithMetadata <- merge(dim1_10, dge.filtered.norm$samples, by = 0, all = TRUE)
pcaWithMetadata$group <- factor(pcaWithMetadata$TYPE,
                                 levels = c(CONTROL, AD, PA, LBD, NA))
# Plotting
ggplot(data = pcaWithMetadata, aes(
  x = PC1,
  y = PC2,
  shape = group,
  color = group
)) +
  geom_point(size = 2) +
  theme_bw() +
#  xlim(-150, 150) +
#  ylim(-150, 150) +
  scale_color_manual(values = c(control_color, AD_color,
                                PA_color, LBD_color,
                                "azure3")) +
  scale_shape_manual(values = c(control_shape, AD_shape,
                                PA_shape, LBD_shape)) +
  theme(
    plot.title = element_text(size = 7, face = "bold"),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 6),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6),
    axis.title.x = element_text(size = 6),
    axis.title.y = element_text(size = 6)
  ) +
  theme(legend.title = element_blank()) +
  xlab("PC1 ") +
  ylab("PC2 ")
```

```{r}
# fits linear model for each gene given a series of arrays
fit <- lmFit(v, design)
coef.fit <- fit$coefficients
head(coef.fit)
# contrast design for differential expression
contrasts <- makeContrasts(
  LBDvsControl = LBD - CONTROL,
  LBDvsAD = LBD - AD,
  LBDvsPA = LBD - PA,
  ADvsControl = AD - CONTROL, 
  PAvsControl = PA - CONTROL,
  ADvsPA = AD - PA, 
  levels = colnames(design))
head(contrasts)

# save contrast names
allComparisons <- colnames(contrasts)
allComparisons # check

# run contrast analysis
vfit <- contrasts.fit(fit, contrasts = contrasts)

# Compute differential expression based on the empirical Bayes moderation of the
# standard errors towards a common value.
veBayesFit <- eBayes(vfit)
plotSA(veBayesFit, main = "Final Model: Mean-variance Trend")

# save
path <- paste0("../../results/", tool, "/voom/LBD_gene_final_mean_var")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```

# Voom MDS Plot
```{r MDS_voom}
group_colors <- c(control_color, 
                  AD_color, 
                  PA_color, 
                  LBD_color)[v$targets$TYPE]
Sex <- v$targets$Sex

plotMDS(
  v, 
  top = 100, 
  labels = Sex,
  cex = 1, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = group_colors, 
  gene.selection = "common"
)

title(expression('Top 100 Genes - Voom (Log'[2]~'CPM)'))

# save
# save
path <- paste0("../../results/", tool, "/MDS/LBD_gene_MDS_voom_sex")
saveToPDF(paste0(path, ".pdf"), width = 5, height = 5)
```

```{r save_EList}
saveRDS(v, file = paste0("../../rObjects/", directory,"gene_voom.rds"))
saveRDS(voomCountsMatrix, file = paste0("../../rObjects/", directory,"voomCountsMatrix.rds"))
```

# Number of DEGs
Identify number of differential expressed genes.
```{r decide_tests}
pval <- 0.05

sumTable <- 
  summary(decideTests(
    vfit,  # object
    adjust.method = "BH", # by default the method = "separate"
    p.value = pval,
    lfc = 0  # numeric, minimum absolute log2-fold change required
  ))

print(paste0(" FDRq < ", pval))
sumTable
topTable(veBayesFit, coef = "LBDvsControl")
```

# Output DEG tables
```{r output_DEG_tables}
coef <- 1

for (i in allComparisons) {
  # p < 1, log2fc > 0 
  vTopTableAll <-
    topTable(
      veBayesFit, 
      coef = coef,  
      n = Inf, 
      p.value = 1,
      lfc = 0 
    )
vTopTableAll <-
  subset(
    vTopTableAll,
    select = -c(
      score,
      phase,
      transcript_id,
      transcript_type,
      transcript_name,
      transcript_support_level,
      exon_number,
      exon_id,
      ont,
      protein_id,
      ccdsid
    )
  )
    saveRDS(vTopTableAll, file = 
            paste0("../../rObjects/", directory, 
                   i,"_LBD_gene_table.rds"))
  path <- paste0("../../results/", directory, tool, "/DEGs/",
  i, "_LBD_gene_DEGs_FDRq1.00.txt", sep = "") 
  write.table(
    vTopTableAll,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # p < 0.05, log2fc > 0
  vTopTable1 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.05,
      lfc = 0
    )
  path <- paste0("../../results/", tool, "/DEGs/",
  i, "_LBD_gene_DEGs_FDRq0.05.txt", sep = "") 
  write.table(
    vTopTable1,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # increment 
  coef <- coef + 1
}
remove(coef)
```

Read table with all genes (FDRq = 1).
```{r read_DEG_table}
coef <- 1

for (i in allComparisons) {
  filepath <- paste0(
    "../../results/",
    tool,
    "/DEGs/",
    i,
    "_LBD_gene_DEGs_FDRq1.00.txt"
  )
  assign(i,
         read.delim(
           filepath,
           header = TRUE,
           sep = "\t",
           stringsAsFactors = FALSE
         ))
  # increment
  coef <- coef + 1
}
```

# Assign colors
Assign colors  values based on FDRq cutoff of 0.05.
```{r assign_colors}
color_values <- vector()
max <- nrow(LBDvsControl)

for(i in 1:max){
  if (LBDvsControl$adj.P.Val[i] < 0.05){
    if (LBDvsControl$logFC[i] > 0){
      color_values <- c(color_values, 1) # 1 when logFC > 0 and FDRq < 0.05
    }
    else if (LBDvsControl$logFC[i] < 0){
      color_values <- c(color_values, 2) # 2 when logFC < 0 and FDRq < 0.05
    }
  }
  else{
    color_values <- c(color_values, 3) # 3 when FDRq >= 0.05
  }
}

LBDvsControl$color_p0.05 <- factor(color_values)
```

# Subset genes to label
Subset the top 10 up and down-regulated genes
```{r}
up <- LBDvsControl[LBDvsControl$color_p0.05 == 1,]
up10 <- up[1:10,]

down <- LBDvsControl[LBDvsControl$color_p0.05 == 2,]
down <- subset(down, down$logFC < -1.5)
down10 <- down[1:7,]
```

# Volcano plot
```{r volcano}
hadjpval <- (-log10(max(
  LBDvsControl$P.Value[LBDvsControl$adj.P.Val < 0.05], 
  na.rm=TRUE)))

p_vol <-
  ggplot(data = LBDvsControl, 
         aes(x = logFC,  # x-axis is logFC
             y = -log10(P.Value),  # y-axis will be -log10 of P.Value
             color = color_p0.05)) +  # color is based on factored color column
  geom_point(alpha = 1.5, size = 1.7) +  # create scatterplot, alpha makes points transparent
  theme_bw() +  # set color theme
  theme(legend.position = "none") +  # no legend
  scale_color_manual(values = c("red", "blue","grey")) +  # set factor colors
  labs(
    title = "", # no main title
    x = expression(log[2](FC)), # x-axis title
    y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
  ) +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 10)) +
  theme(axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 10)) +
  geom_hline(yintercept = hadjpval,  #  horizontal line
                     colour = "#000000",
                     linetype = "dashed") +
  ggtitle("LBD vs Control\nFDRq < 0.05") +
  theme(plot.title = element_text(size = 10)) +
  geom_text_repel(data = up10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "maroon", 
                  fontface="italic",
                  size = 4, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                  ) +
  geom_text_repel(data = down10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "navyblue", 
                  fontface="italic",
                  size = 4, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 15)
                  )  #+
 # scale_y_continuous(breaks = seq(0,8,by=1), limits = c(0,8)) +
 # scale_x_continuous(breaks = seq(-3,3,by=1), limits = c(-3,3))
p_vol

# save
path <- paste0("../../results/", tool, "/volcano/LBD_gene_volcano_FDRq0.05")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```

```{r}
glimmaVolcano(veBayesFit, coef = 1,  dge = dge.filtered.norm, groups = dge.filtered.norm$samples$TYPE, display.columns=c("gene_name", "AdjPValue", "seqnames"))
glimmaVolcano()
help(glimmaVolcano)
sessionInfo()
```

