---
title: "Differential expression in LBD samples"
author: "Kimberly Olney, Ph.D."
date: "09/30/2022"
output:
  html_document:
    df_print: paged
  pdf_document: default
params:
  args: myarg
---
Samples have already been sex checked and realigned to the SCC reference. 
# Setup
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```
BiocManager::install("pcaExplorer")
```{r libraries, message=FALSE, warning=FALSE}
library(DESeq2)
library(DEGreport)
library(pheatmap)
library(viridis)
library(factoextra)
library(ggsci)
library(pcaExplorer)
```
# User defined variables
```{r set_variables}
source(here::here("scripts/R", "file_paths_and_colours.R"))
myContrasts <- c("LBD - CONTROL")
tool = c("star")
directory <- c("pass_DESeq/")
condition <- c("All_samples")
```
# read in data 
```{r}
# read in metadata
# the expanded metadata contains inferred sex, RIN, and WGS sample IDs
metadata <- vroom(paste0(pathToRawData, "metadata_expanded.tsv"))
# remove duplicates if any 
metadata <- metadata[!duplicated(metadata[,c('RNA.config.ID')]),]
metadata$TYPE <- gsub(" - ", "_", metadata$TYPE) 

metadata <- metadata %>% mutate(sex_chr = case_when(
  startsWith(sex_inferred, "female") ~ "XX", 
  startsWith(sex_inferred, "male") ~ "XY"))

# remove rows with no inferred sex.
# No counts data for this samples because there is no RNAseq data for that individual
metadata <- metadata[!is.na(metadata$sex_inferred),]

# example of file naming:
# NA12-254_FCHCLTJDMXY_L1_STAR_XY.bamReadsPerGene.out.tab
# path to counts files
count_files <-
  file.path(paste0(
    "../../starAligned_SCC/",
    metadata$NPID,
    "_FC",
    metadata$flowcell_and_lane,
    "_STAR_",
    metadata$sex_chr,
    typeOfCount
  ))
# add sample name to counts files
names(count_files) <- paste0(metadata$NPID)
# add sample count path information to metadata
metadata$path <- count_files
# make sure there is only unique paths

counts <- data.frame(fread(count_files[1]))[c(1, 2)]
# Loop and read the 2nd column remaining files
for (i in 2:length(count_files)) {
  counts <- cbind(counts, data.frame(fread(count_files[i]))[2])
}
# remove star metric information
counts <- counts[!grepl("N_", counts$V1),]
# set gene_id (i.e. V1) as the row name
row.names(counts) <- counts$V1
counts$V1 <- NULL
# set column names to NPID sample ID
colnames(counts) <- metadata$RNA.config.ID
```

```{r}
# read in metadata
# the expanded metadata contains inferred sex, RIN, and WGS sample IDs
metadata <- vroom(paste0(pathToRawData, "RNA_metadata.tsv"))
# remove duplicates if any 
metadata <- metadata[!duplicated(metadata[,c('RNA.config.ID')]),]
# rename columns for easier plotting 
# names(metadata)[names(metadata) == "TYPE"] <- "Disease group"
metadata <- metadata %>%
  mutate(across('TYPE', str_replace, 'CONTROL - AD', 'AD'))
metadata <- metadata %>%
  mutate(across('TYPE', str_replace, 'CONTROL - PA', 'PA'))
metadata$TYPE <- factor(metadata$TYPE, levels = c("CONTROL", "AD", "PA", "LBD"))


metadata <- metadata %>% mutate(sex_chr = case_when(
  startsWith(sex_inferred, "female") ~ "XX", 
  startsWith(sex_inferred, "male") ~ "XY"))

# remove rows with no inferred sex.
# No counts data for this samples because there is no RNAseq data for that individual
metadata <- metadata[!is.na(metadata$sex_inferred),]

# example of file naming:
# NA12-254_FCHCLTJDMXY_L1_STAR_XY.bamReadsPerGene.out.tab
# path to counts files
count_files <-
  file.path(paste0(
    "../../starAligned_SCC/",
    metadata$NPID,
    "_STAR_",
    metadata$sex_chr,
    typeOfCount
  ))
# add sample name to counts files
names(count_files) <- paste0(metadata$NPID)
# add sample count path information to metadata
metadata$path <- count_files
# make sure there is only unique paths
```
### create a counts matrix
```{r}
counts <- data.frame(fread(count_files[1]))[c(1, 2)]
# Loop and read the 2nd column remaining files
for (i in 2:length(count_files)) {
  counts <- cbind(counts, data.frame(fread(count_files[i]))[2])
}
# remove star metric information
counts <- counts[!grepl("N_", counts$V1),]
# set gene_id (i.e. V1) as the row name
row.names(counts) <- counts$V1
counts$V1 <- NULL
# set column names to NPID sample ID
colnames(counts) <- metadata$NPID
```

# create DESeq object
```{r}
rownames(metadata) <- metadata$NPID
dds <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~TYPE)

ddsColl <- collapseReplicates(dds, dds$NPID)
ddsColl_DE <- DESeq(ddsColl)
saveRDS(dds, file = paste0("../../rObjects/", directory, "LBD_SCC_DESeq_raw.rds"))
```
# filter counts
```{r}
filter_count <- DEGreport::degFilter(counts = counts(ddsColl_DE),
                                     metadata = as.data.frame(colData(ddsColl_DE)),
                                     group = "TYPE",
                                     min = 1, # All samples in group must have more than expr > 0
                                     minreads = 0) 
cat("Genes in final count matrix: ", nrow(filter_count))
```
# vst
```{r}
vsd <- vst(object = ddsColl_DE, 
           blind = TRUE # blind to experimental design   
)
```
# compute sample distances
Transpose transformed count matrix, such that samples now rows.
Compute distances between rows of the matrix i.e. sample-to-sample distance.
Convert to matrix.
Define row names. 
```{r}
sampleDists <- vsd %>% 
  assay() %>% 
  t() %>% 
  dist(method = "euclidean")  

sampleDistMatrix <- sampleDists %>% 
  as.matrix() 

rownames(sampleDistMatrix) <- str_c(vsd$sample_id, ": ", vsd$TYPE, ", ", vsd$sex_inferred)
rownames(sampleDistMatrix) <- str_c(vsd$TYPE)

colnames(sampleDistMatrix) <- NULL
```
# heatmap
```{r, eval = FALSE}
dis_heatmap <- pheatmap(sampleDistMatrix,
                     clustering_distance_rows=sampleDists,
                     clustering_distance_cols=sampleDists,
                     col= viridis(n = 20), 
                     main = "Heatmap: uncorrected data")
dis_heatmap
path <- paste0("../../results/", directory, "/heatmap/", 
               condition,"_euclidean_uncorrected")
saveToPDF(paste0(path, ".pdf"), width = 30, height = 30)
```
```{r}
pheatmap

```

# pca & tree
```{r}
pca_vsd <- prcomp(t(assay(vsd)))

tibble(PC = c(1:24), 
       sdev = pca_vsd$sdev) %>% 
  dplyr::mutate(d = sdev^2, 
                pev = d/sum(d), 
                cev = cumsum(d)/sum(d))

ggarrange(pcascree(pca_vsd, type = "pev"),
          pcascree(pca_vsd, type = "cev"), 
          nrow = 2,
          labels = c("a", "b"))


rlt <- DESeq2::rlogTransformation(dds)
pcaobj <- prcomp(t(SummarizedExperiment::assay(rlt)))
pcascree(pcaobj,type="pev")
pcascree(pcaobj,type="cev",title="Cumulative explained proportion of variance")
```
# PC correlation
```{r}
# Source function correlate PCs
source(here::here("scripts/R", "correlatePCs.R"))

# Select col 1-20 (excludes Unclassified with NAs)
PC_corr <- correlatePCs(pcaobj = pca_vsd, coldata = colData(vsd)[,1:19], pcs = 1:24)

PC_corr_FDR_uncorrected <- PC_corr$pvalue %>% 
  as_tibble() %>% 
  dplyr::mutate(PC = str_c("PC_", c(1:24))) %>% 
  dplyr::select(-NPID) %>% 
  tidyr::gather(key = covariate, value = p, -PC) %>% 
  dplyr::mutate(FDR = p.adjust(p, method = "fdr"))
```

```{r}
PC_corr_FDR_mat <- PC_corr_FDR_uncorrected %>% 
  dplyr::select(-p) %>% 
  tidyr::spread(key = covariate, value = FDR) %>% 
  dplyr::mutate(PC_number = str_replace(PC, "PC_", "") %>% 
                  as.numeric()) %>% 
  dplyr::arrange(PC_number) %>% 
  dplyr::select(-PC_number, -PC) %>% 
  as.matrix()

PC_corr_FDR_mat <- PC_corr_FDR_mat[, match(colnames(PC_corr$statistic), colnames(PC_corr_FDR_mat))]
rownames(PC_corr_FDR_mat) <- PC_corr_FDR_uncorrected %>% .[["PC"]] %>% unique()

heatmap.2(x = -log10(PC_corr_FDR_mat) %>% t(), 
          Colv = NA, 
          Rowv = NA,
          dendrogram = "none",
          col = viridis(n = 50),
          trace = "none",
          density.info = "none", 
          key = TRUE, 
          key.xlab = "-log10(FDR-corrected p-value)", 
          cexRow = 0.65, cexCol = 0.65)

```
# Design sex, RIN, 
```{r}
metadata
metadata$RIN[is.na(metadata$RIN)] <- 0
dds_cov_variables <- DESeqDataSetFromMatrix(countData=counts, 
                              colData=metadata, 
                              design=~sex_inferred + RIN + Age + TYPE)
filter_count <- DEGreport::degFilter(counts = counts(dds_cov_variables),
                                     metadata = as.data.frame(colData(dds_cov_variables)),
                                     group = "TYPE",
                                     min = 1, # All samples in group must have more than expr > 0
                                     minreads = 0) 
cat("Genes in final count matrix: ", nrow(filter_count))
filter_dds <- dds_cov_variables[rownames(filter_count),] 

vsd_covar <- vst(filter_dds,
                     blind = FALSE)

# Batch correcting and filtering vsd data 
design <- model.matrix(design(dds_cov_variables), data = colData(dds_cov_variables))
design

design <- c()
design_treatment <- design[,c("(Intercept)", "TYPEAD", "TYPEPA", "TYPELBD")]
design_batch <- design[,c("sex_inferredmale", "RIN", "Age")] %>% scale()

assay(vsd_covar) <- limma::removeBatchEffect(assay(vsd_covar), design = design_treatment, covariates = design_batch)

# Check that rowMeans are equal following removal of batch effects
identical(c(assay(vsd) %>% 
              rowMeans() %>%
              round(digits = 5)),
          c(assay(vsd_covar) %>% 
              rowMeans() %>%
              round(digits = 5)))

```
```{r}
sampleDists <- vsd_covar %>% 
  assay() %>% 
  t() %>% # Transpose transformed count matrix, such that samples now rows.
  dist(method = "euclidean") # Compute distances between rows of the matrix i.e. sample-to-sample distance
  
sampleDistMatrix <- sampleDists %>% 
  as.matrix() # Convert to matrix

rownames(sampleDistMatrix) <- str_c(vsd_covar$TYPE)
colnames(sampleDistMatrix) <- NULL
pheatmap <- pheatmap(sampleDistMatrix,
                     clustering_distance_rows=sampleDists,
                     clustering_distance_cols=sampleDists,
                     col= viridis(n = 20), 
                     main = "Heatmap: corrected by AoD, RIN, Sex")
```
# PC corrections
```{r}
pca_vsd_covar <- prcomp(t(assay(vsd_covar)))

PC_corr <- 
  correlatePCs(pcaobj = pca_vsd_covar, 
               coldata = colData(vsd_covar)[!colnames(colData(vsd_covar)) %in% c("sex_inferred", "Age", "RIN",
                                                               str_c("PC", 1:4),
                                                               "sizeFactor")], pcs = 1:625)

PC_corr_FDR_covar <- PC_corr$pvalue %>% 
  as_tibble() %>% 
  dplyr::mutate(PC = str_c("PC_", c(1:625))) %>% 
  dplyr::select(-sample_id) %>% 
  tidyr::gather(key = covariate, value = p, -PC) %>% 
  dplyr::mutate(FDR = p.adjust(p, method = "fdr"))

PC_corr_FDR_covar %>% 
  dplyr::inner_join(PC_corr$statistic %>% 
               as_tibble() %>% 
               dplyr::mutate(PC = str_c("PC_", c(1:625))) %>% 
               dplyr::select(-sample_id) %>% 
               tidyr::gather(key = covariate, value = test_statistic, -PC)) %>% 
  dplyr::arrange(FDR)
```
# compare between models
```{r}
list_vsd <- list(pca_vsd)
plot_list <- vector(mode = "list", length = 1)
titles <- c("Uncorrected")

for(i in 1:length(list_vsd)){
  
  plot_list[[i]] <- fviz_pca_ind(list_vsd[[i]],
                                 geom.ind = "point", # show points only (nbut not "text")
                                 col.ind = colData(vsd)[,c("TYPE")], # color by groups
                                 addEllipses = TRUE, ellipse.type = "confidence", # Confidence ellipses
                                 palette =  pal_jco("default", alpha = 0.9)(10)[c(3,9,1,2)],
                                 mean.point = FALSE,
                                 legend.title = "Disease group", 
                                 title = titles[i]
  )
  
}

ggarrange(plotlist = plot_list,
          labels = c("a"),
          nrow = 1)
```