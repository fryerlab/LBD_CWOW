---
title: "Differential expression in LBD samples"
author: "Kimberly Olney, Ph.D."
date: "09/30/2022"
output:
  html_document:
    df_print: paged
  pdf_document: default
params:
  args: myarg
---
Samples have already been sex checked and realigned to the SCC reference. 
# Setup
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```

# User defined variables
```{r set_variables}
source(here::here("scripts/R", "file_paths_and_colours.R"))

directory <- c("pass1/")
condition <- c("All_samples")

myContrasts <- c("LBDvsControl = LBD - CONTROL",
  "LBDvsAD = LBD - AD",
  "LBDvsPA = LBD - PA",
  "ADvsControl = AD - CONTROL", 
  "PAvsControl = PA - CONTROL",
  "ADvsPA = AD - PA")
tool = c("star")
typeOfCount <-  c(".bamReadsPerGene.out.tab")
```

# Read data
### metadata
```{r read_data}
# example of file naming:
# NA12-254_FCHCLTJDMXY_L1_STAR_XY.bamReadsPerGene.out.tab
# path to counts files
count_files <-
  file.path(paste0(
    "../../starAligned_SCC/",
    metadata$NPID,
    "_STAR_",
    metadata$sex_chr,
    typeOfCount
  ))
# add sample name to counts files
names(count_files) <- paste0(metadata$NPID)
# add sample count path information to metadata
metadata$path <- count_files
# make sure there is only unique paths
```
### create a counts matrix
```{r}
counts <- data.frame(fread(count_files[1]))[c(1, 2)]
# Loop and read the 2nd column remaining files
for (i in 2:length(count_files)) {
  counts <- cbind(counts, data.frame(fread(count_files[i]))[2])
}
```
# Star mapping metrics
```{r}
star_metrics <- data.frame(counts[counts$V1 %like% "N_", ])
star_metrics$V1 <- as.vector(star_metrics$V1)
melt_star_metrics <- reshape::melt(star_metrics, id = c("V1"))
ggplot(melt_star_metrics, aes(x = value, fill = V1)) + 
  geom_histogram(position = "identity", bins = 100) + 
  facet_grid(V1 ~ .)  + theme_bw()
```
clean up
```{r}
# clean up
remove(melt_star_metrics, 
       params, 
       star_metrics)
```
# format counts table
```{r}
# remove star metric information
counts <- counts[!grepl("N_", counts$V1),]
# set gene_id (i.e. V1) as the row name
row.names(counts) <- counts$V1
counts$V1 <- NULL
# set column names to NPID sample ID
colnames(counts) <- metadata$NPID
```

# Check inputs
```{r}
all.equal(rownames(counts), genes.gtf$gene_id)
all.equal(colnames(counts), (metadata$NPID))
```
# Create DGE object
```{r DGE_object}
# create object
dge <- DGEList(counts = counts,
               samples = metadata,
               genes = genes.gtf)

table(dge$samples$TYPE)
```

# Save R object
```{r, eval=FALSE}
saveRDS(dge, file = paste0("../../rObjects/", condition, "_dge.raw.rds"))
dge <- readRDS(paste0("../../rObjects/", condition, "_dge.raw.rds"))
```

# Remove mitochondrial genes & keep only protein coding genes
```{r MT_genes}
dim(dge)
removeMT <- dge$genes$seqnames != "chrM"  # true when NOT MT
dge <- dge[removeMT,,keep.lib.sizes = FALSE]
keepProtein <- dge$genes$gene_type == "protein_coding"
dge <- dge[keepProtein,,keep.lib.sizes = FALSE]
dim(dge)
```
# Raw MDS
convert counts to cpm and lcpm
set colors and get data
```{r cpm, warning=FALSE}
lcpm <- edgeR::cpm(dge$counts, log = TRUE)
cpm <- edgeR::cpm(dge$counts, log = FALSE)
# sex colors 
dge$samples$sex_inferred <- as.factor(dge$samples$sex_inferred)
sex_colors <- c(SexColors)[dge$samples$sex_inferred]
```

```{r}
par(bg = 'white')

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))

path <- paste0("../../results/", tool, "/MDS/", 
               condition,"_MDS_label_sex_dim1&2")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(2,3), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))
path <- paste0("../../results/", tool, "/MDS/", 
               condition,"_MDS_label_sex_dim2&3")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```

# Filtering and RIN check
The filterByExpr() function in the edgeR package determines which genes have a 
great enough count value to keep.  We will filter by group.  This means at least 
6 samples (6 is the smallest group sample size) must express a minimum count of 
10 (in cpm, default value).
```{r}
# first filter by expression and normalize the data
keep.expr <- filterByExpr(dge, group = dge$samples$TYPE)
dim(dge)
dge.filtered <- dge[keep.expr, , keep.lib.sizes = FALSE]

dim(dge.filtered)
table(dge.filtered$genes$gene_type)

# Now, normalization by the method of trimmed mean of M-values (TMM)
dge.filtered.norm <- calcNormFactors(dge.filtered, method = "TMM")

# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = T)
nsamples <- ncol(dge.filtered.norm)
# Create a vector named "new_order" containing the desired order
boxplot(log2cpm.norm, 
        main="Filtered normalized lcpm data", 
        xlab="RIN", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE)
axis(2)
axis(1,at=1:nsamples,labels=(dge.filtered.norm$samples$RIN),las=2,cex.axis=0.8)

path <- paste0("../../results/", tool, "/library/", condition, "boxplot_RIN")
saveToPDF(paste0(path, ".pdf"), width = 35, height = 6)
```

# RIN check with replicates summed
```{r}
# check if there is correlation between RIN and library size
box <- dge.filtered.norm$samples

cor(box$RIN, box$lib.size, method = c("pearson", "kendall", "spearman"))
cor.test(box$RIN, box$lib.size, method=c("pearson", "kendall", "spearman"))

# is the data normally distrubited 
ggqqplot(box$lib.size, ylab = "library size")
# wt
ggqqplot(box$RIN, ylab = "RIN")
res <- cor.test(box$lib.size, box$RIN, 
                method = "pearson")
res

ggscatter(box, x = "RIN", y = "lib.size", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          ylab = "library size", xlab = "RIN value") 

path <- paste0("../../results/", tool, "/library/", condition, "_corr_RIN_lib_size")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 6)
```

# Raw MDS
```{r}
par(bg = 'white')

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge.filtered.norm$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = sex_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))

path <- paste0("../../results/", tool, "/MDS/", 
               condition,"_gene_MDS_label_sex_dim1&2")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```


```{r TMM_normalize}
# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
```

# Density plot
Density plots of log-intensity distribution of each library can be superposed 
on a single graph for a better comparison between libraries and for 
identification of libraries with weird distribution. 
```{r density_plots}
# set graphical parameter
par(mfrow = c(1,3))

# Normalize data for library size and expression intesntiy
log2cpm.tech <- edgeR::cpm(dge, log = TRUE)
log2cpm.filtered <- edgeR::cpm(dge.filtered, log = TRUE)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = TRUE)

# set colors
colors <- colorbindColors
nsamples <- ncol(dge)

# First, plot the first column of the log2cpm.tech density
plot(density(log2cpm.tech[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "A. Raw", xlab = expression('Log'[2]~CPM))

# For each sample plot the lcpm density
for (i in 2:nsamples){
  den <- density(log2cpm.tech[,i]) #subset each column
  lines(den$x, den$y, col = colors[i], lwd = 2) 
}

# Second, plot log2cpm.filtered
plot(density(log2cpm.filtered[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "B. Filtered", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.filtered[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# Third, plot log2cpm.norm
plot(density(log2cpm.norm[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "C. Normalized", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.norm[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# save
path <- paste0("../../results/", tool, "/library/", condition,"_gene_density")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```


```{r}
remove(box,
       res)
```

```{r}
remove(
       dge, 
       dge.filtered,
       lcpm,
       log2cpm.filtered,
       log2cpm.norm,
       log2cpm.tech)
```

# Save R object
```{r}
saveRDS(dge.filtered.norm, file = paste0("../../rObjects/", condition, ".dge.filtered.norm.rds"))
dge.filtered.norm <- readRDS(paste0("../../rObjects/", condition ,".dge.filtered.norm.rds"))
```

# Design matrix
```{r design_matrix}
dge.filtered.norm$samples$RIN[is.na(dge.filtered.norm$samples$RIN)] <- 1

design <- model.matrix(~ 0 + TYPE + RIN + Age + sex_inferred + APOE + Race,  dge.filtered.norm$samples)
colnames(design) <- c(CONTROL, AD, PA, LBD, "RIN", "Age", "sex", "E2E4", "E3E3", "E3E4", "E4E4", "Asian_American","Caucasian","Eastern_Indian", "Hispanic", "Native_American")
```

# Voom
```{r voom}
# voom transform counts
#v <- voomWithQualityWeights(dge.filtered.norm,
#                            design,
#                            plot = FALSE)

# no weights needed with this large sample size
v <- voom(dge.filtered.norm, design, plot=TRUE)
path <- paste0("../../results/", tool, "/voom/", condition, "_gene_mean_voom")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```
# PCA on all/the most variable genes
Select most variable genes based on the biological 
coefficient of variance
```{r pca, cache=TRUE}
# Voom transformed counts
voomCounts <- v$E
voomCountsMatrix <- data.matrix(voomCounts, rownames.force = NA)
# Setting the N of genes to use
ntop = length(dge.filtered.norm$genes$gene_id)
# Sorting by the coefficient of variance
means <- rowMeans(voomCountsMatrix)
Pvars <- rowVars(voomCountsMatrix)
cv2 <- Pvars / means ^ 2
select <-
  order(cv2, decreasing = TRUE)[seq_len(min(ntop, length(cv2)))]
highly_variable_exp <- ((voomCountsMatrix)[select,])
# Running PCA
pca_exp <- prcomp(t(highly_variable_exp), scale = F, center = T)
# scale a logical value indicating whether the variables should be scaled
# to have unit variance before the analysis takes place.
# a logical value indicating whether the variables should be shifted to be zero centered.
head(pca_exp$x)[, 1:3]
#summary(pca_exp)
# Dataframe with the first 10 PCs
dim1_10 <- data.frame(pca_exp$x[, 1:10])
# Adding metadata
pcaWithMetadata <- merge(dim1_10, dge.filtered.norm$samples, by = 0, all = TRUE)
pcaWithMetadata$group <- factor(pcaWithMetadata$TYPE,
                                 levels = c(CONTROL, AD, PA, LBD, NA))
# Plotting
ggplot(data = pcaWithMetadata, aes(
  x = PC1,
  y = PC2,
  shape = group,
  color = group
)) +
  geom_point(size = 2) +
  theme_bw() +
#  xlim(-150, 150) +
#  ylim(-150, 150) +
  scale_color_manual(values = c(control_color, AD_color,
                                PA_color, LBD_color,
                                "azure3")) +
  scale_shape_manual(values = c(control_shape, AD_shape,
                                PA_shape, LBD_shape)) +
  theme(
    plot.title = element_text(size = 7, face = "bold"),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 6),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6),
    axis.title.x = element_text(size = 6),
    axis.title.y = element_text(size = 6)
  ) +
  theme(legend.title = element_blank()) +
  xlab("PC1 ") +
  ylab("PC2 ")
```

```{r}
# fits linear model for each gene given a series of arrays
fit <- lmFit(v, design)
coef.fit <- fit$coefficients
head(coef.fit)
# contrast design for differential expression
contrasts <- makeContrasts(
  LBDvsControl = LBD - CONTROL,
  LBDvsAD = LBD - AD,
  LBDvsPA = LBD - PA,
  ADvsControl = AD - CONTROL, 
  PAvsControl = PA - CONTROL,
  ADvsPA = AD - PA, 
  levels = colnames(design))
head(contrasts)

# save contrast names
allComparisons <- colnames(contrasts)
allComparisons # check

# run contrast analysis
vfit <- contrasts.fit(fit, contrasts = contrasts)

# Compute differential expression based on the empirical Bayes moderation of the
# standard errors towards a common value.
veBayesFit <- eBayes(vfit)
plotSA(veBayesFit, main = "Final Model: Mean-variance Trend")

# save
path <- paste0("../../results/", tool, "/voom/", condition, "_gene_final_mean_var")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```

# Voom MDS Plot
```{r MDS_voom}
group_colors <- c(control_color, 
                  AD_color, 
                  PA_color, 
                  LBD_color)[v$targets$TYPE]
Sex <- v$targets$Sex

plotMDS(
  v, 
  top = 100, 
  labels = Sex,
  cex = 1, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = group_colors, 
  gene.selection = "common"
)

title(expression('Top 100 Genes - Voom (Log'[2]~'CPM)'))

# save
# save
path <- paste0("../../results/", tool, "/MDS/", condition, "_gene_MDS_voom_sex")
saveToPDF(paste0(path, ".pdf"), width = 5, height = 5)
```

```{r save_EList}
saveRDS(v, file = paste0("../../rObjects/", condition,".gene_voom.rds"))
saveRDS(voomCountsMatrix, file = paste0("../../rObjects/", condition,".voomCountsMatrix.rds"))
```

# Number of DEGs
Identify number of differential expressed genes.
```{r decide_tests}
pval <- 0.05

sumTable <- 
  summary(decideTests(
    vfit,  # object
    adjust.method = "BH", # by default the method = "separate"
    p.value = pval,
    lfc = 0  # numeric, minimum absolute log2-fold change required
  ))

print(paste0(" FDRq < ", pval))
sumTable
topTable(veBayesFit, coef = "LBDvsControl")
```

# Output DEG tables
```{r output_DEG_tables}
coef <- 1

for (i in allComparisons) {
  # p < 1, log2fc > 0 
  vTopTableAll <-
    topTable(
      veBayesFit, 
      coef = coef,  
      n = Inf, 
      p.value = 1,
      lfc = 0 
    )
vTopTableAll <-
  subset(
    vTopTableAll,
    select = -c(
      score,
      phase,
      transcript_id,
      transcript_type,
      transcript_name,
      transcript_support_level,
      exon_number,
      exon_id,
      ont,
      protein_id,
      ccdsid
    )
  )
    saveRDS(vTopTableAll, file = 
            paste0("../../rObjects/", 
                   i,"_gene_table.rds"))
  path <- paste0("../../results/", tool, "/DEGs/",
  i, "_gene_DEGs_FDRq1.00.txt", sep = "") 
  write.table(
    vTopTableAll,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # p < 0.05, log2fc > 0
  vTopTable1 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.05,
      lfc = 0
    )
  path <- paste0("../../results/", tool, "/DEGs/",
  i, "_gene_DEGs_FDRq0.05.txt", sep = "") 
  write.table(
    vTopTable1,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # increment 
  coef <- coef + 1
}
remove(coef)
```

Read table with all genes (FDRq = 1).
```{r read_DEG_table}
allComparisons <- c("LBDvsControl", "ADvsControl", "PAvsControl")
coef <- 1

for (i in allComparisons) {
  filepath <- paste0(
    "../../results/",
    tool,
    "/DEGs/",
    i,
    "_gene_DEGs_FDRq1.00.txt"
  )
  assign(i,
         read.delim(
           filepath,
           header = TRUE,
           sep = "\t",
           stringsAsFactors = FALSE
         ))
  # increment
  coef <- coef + 1
}
```

# Assign colors
Assign colors  values based on FDRq cutoff of 0.05.
```{r assign_colors}
color_values <- vector()
max <- nrow(PAvsControl)

for(i in 1:max){
  if (PAvsControl$adj.P.Val[i] < 0.05){
    if (PAvsControl$logFC[i] > 0){
      color_values <- c(color_values, 1) # 1 when logFC > 0 and FDRq < 0.05
    }
    else if (PAvsControl$logFC[i] < 0){
      color_values <- c(color_values, 2) # 2 when logFC < 0 and FDRq < 0.05
    }
  }
  else{
    color_values <- c(color_values, 3) # 3 when FDRq >= 0.05
  }
}

PAvsControl$color_p0.05 <- factor(color_values)
```

# Subset genes to label
Subset the top 10 up and down-regulated genes
```{r}
up <- PAvsControl[PAvsControl$color_p0.05 == 1,]
up10 <- up[1:10,]

down <- PAvsControl[PAvsControl$color_p0.05 == 2,]
down10 <- down[1:7,]
```

# Volcano plot
```{r volcano}
hadjpval <- (-log10(max(
  PAvsControl$P.Value[PAvsControl$adj.P.Val < 0.05], 
  na.rm=TRUE)))

p_vol <-
  ggplot(data = PAvsControl, 
         aes(x = logFC,  # x-axis is logFC
             y = -log10(P.Value),  # y-axis will be -log10 of P.Value
             color = color_p0.05)) +  # color is based on factored color column
  geom_point(alpha = 1.5, size = 1.7) +  # create scatterplot, alpha makes points transparent
  theme_bw() +  # set color theme
  theme(legend.position = "none") +  # no legend
  scale_color_manual(values = c("red", "blue","grey")) +  # set factor colors
  labs(
    title = "", # no main title
    x = expression(log[2](FC)), # x-axis title
    y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") # y-axis title
  ) +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 10)) +
  theme(axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 10)) +
  geom_hline(yintercept = hadjpval,  #  horizontal line
                     colour = "#000000",
                     linetype = "dashed") +
  ggtitle("PA vs Control\nFDRq < 0.05") +
  theme(plot.title = element_text(size = 10)) +
  geom_text_repel(data = up10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "maroon", 
                  fontface="italic",
                  size = 4, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                  ) +
  geom_text_repel(data = down10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "navyblue", 
                  fontface="italic",
                  size = 4, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 15)
                  )  #+
 # scale_y_continuous(breaks = seq(0,8,by=1), limits = c(0,8)) +
 # scale_x_continuous(breaks = seq(-3,3,by=1), limits = c(-3,3))
p_vol

# save
path <- paste0("../../results/", tool, "/volcano/PA_gene_volcano_FDRq0.05")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```
# glimma
```{r}
#saveRDS(veBayesFit, file = paste0("../../rObjects/", condition, ".veBayesFit.rds"))

veBayesFit <- readRDS(paste0("../../rObjects/", condition, ".veBayesFit.rds"))
dge.filtered.norm <- readRDS(paste0("../../rObjects/", condition, ".dge.filtered.norm.rds"))
```

```{r}
glimmaVolcano(veBayesFit, coef = 5,  dge = dge.filtered.norm, groups = dge.filtered.norm$samples$TYPE, display.columns=c("gene_name", "AdjPValue", "seqnames"))
```

