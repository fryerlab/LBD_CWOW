---
title: "AD vs Control"
author: "Kimberly Olney, Ph.D."
date: "09/30/2022"
output:
  html_document:
    df_print: paged
  pdf_document: default
params:
  args: myarg
---
Samples have already been sex checked and realigned to the SCC reference. 
# Setup
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```

# User defined variables
```{r set_variables}
source(here::here("scripts/R", "file_paths_and_colours.R"))

directory <- c("pass1/")
comparison <- c("ADvsControl")
condition <- c("AD")

myContrasts <- c(
  "ADvsControl = AD - CONTROL")
tool = c("star")
typeOfCount <-  c(".bamReadsPerGene.out.tab")
```

# Read data
### metadata
```{r read_data}
# subset metadata and counts before making DGE object
metadata <- subset(metadata, TYPE == "AD" | TYPE == "CONTROL")

# example of file naming:
# NA12-254_FCHCLTJDMXY_L1_STAR_XY.bamReadsPerGene.out.tab
# path to counts files
count_files <-
  file.path(paste0(
    "../../starAligned_SCC/",
    metadata$NPID,
    "_STAR_",
    metadata$sex_chr,
    typeOfCount
  ))
# add sample name to counts files
names(count_files) <- paste0(metadata$NPID)
# add sample count path information to metadata
metadata$path <- count_files
# make sure there is only unique paths
```

### create a counts matrix
```{r}
counts <- data.frame(fread(count_files[1]))[c(1, 2)]
# Loop and read the 2nd column remaining files
for (i in 2:length(count_files)) {
  counts <- cbind(counts, data.frame(fread(count_files[i]))[2])
}
```
# Star mapping metrics
```{r}
star_metrics <- data.frame(counts[counts$V1 %like% "N_", ])
star_metrics$V1 <- as.vector(star_metrics$V1)
melt_star_metrics <- reshape::melt(star_metrics, id = c("V1"))
ggplot(melt_star_metrics, aes(x = value, fill = V1)) + 
  geom_histogram(position = "identity", bins = 100) + 
  facet_grid(V1 ~ .)  + theme_bw()
```
clean up
```{r}
# clean up
remove(melt_star_metrics, 
       params, 
       star_metrics)
```

# format counts table
```{r}
# remove star metric information
counts <- counts[!grepl("N_", counts$V1),]
# set gene_id (i.e. V1) as the row name
row.names(counts) <- counts$V1
counts$V1 <- NULL
# set column names to NPID sample ID
colnames(counts) <- metadata$NPID
```

# Check inputs
genes.gft is from the sources R script 
```{r}
all.equal(rownames(counts), genes.gtf$gene_id)
all.equal(colnames(counts), (metadata$NPID))
```

# Create DGE object
```{r DGE_object}
dge <- DGEList(counts = counts,
               samples = metadata,
               genes = genes.gtf)

table(dge$samples$TYPE)
```

# Remove mitochondrial genes & keep only protein coding genes
```{r MT_genes}
dim(dge)
removeMT <- dge$genes$seqnames != "chrM"  # true when NOT MT
dge <- dge[removeMT,,keep.lib.sizes = FALSE]
keepProtein <- dge$genes$gene_type == "protein_coding"
dge <- dge[keepProtein,,keep.lib.sizes = FALSE]
dim(dge)
```

# Save R object
```{r, eval=FALSE}
saveRDS(dge, file = paste0("../../rObjects/", comparison, ".dge.raw.rds"))
dge <- readRDS(paste0("../../rObjects/", comparison,".dge.raw.rds"))
```
# Raw MDS
convert counts to cpm and lcpm
set colors and get data
```{r cpm, warning=FALSE}
lcpm <- edgeR::cpm(dge$counts, log = TRUE)
cpm <- edgeR::cpm(dge$counts, log = FALSE)
dge$samples$sex_inferred <- as.factor(dge$samples$sex_inferred)
sex_colors <- c(SexColors)[dge$samples$sex_inferred]

type_colors <- c(colorbindColors)[dge$samples$TYPE]
```


```{r}
par(bg = 'white')

# plot MDS
plotMDS(
  lcpm,
  top = 100, 
  labels = dge$samples$sex_inferred,
  cex = .8, 
  dim.plot = c(1,2), 
  plot = TRUE, 
  col = type_colors,
  gene.selection = "common"
)
title(expression('Top 100 Genes (Log'[2]~'CPM)'))

path <- paste0("../../results/", tool, "/MDS/", 
               comparison,"_MDS_label_sex_dim1&2")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```


# Filtering and RIN check
The filterByExpr() function in the edgeR package determines which genes have a 
great enough count value to keep.  We will filter by group.  This means at least 
6 samples (6 is the smallest group sample size) must express a minimum count of 
10 (in cpm, default value).
```{r}
# first filter by expression and normalize the data
keep.expr <- filterByExpr(dge, group = dge$samples$TYPE)
dim(dge)
dge.filtered <- dge[keep.expr, , keep.lib.sizes = FALSE]

dim(dge.filtered)
table(dge.filtered$genes$gene_type)

# Now, normalization by the method of trimmed mean of M-values (TMM)
dge.filtered.norm <- calcNormFactors(dge.filtered, method = "TMM")

# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = T)
nsamples <- ncol(dge.filtered.norm)
# Create a vector named "new_order" containing the desired order
boxplot(log2cpm.norm, 
        main="Filtered normalized lcpm data", 
        xlab="RIN", 
        ylab=expression('Counts per gene (Log'[2]~'CPM)'),
        axes=FALSE)
axis(2)
axis(1,at=1:nsamples,labels=(dge.filtered.norm$samples$RIN),las=2,cex.axis=0.8)

path <- paste0("../../results/", tool, "/library/", comparison,"_boxplot_RIN")
saveToPDF(paste0(path, ".pdf"), width = 35, height = 6)
```
```{r TMM_normalize}
# norm factor summary
summary(dge.filtered.norm$samples$norm.factors)
```

# Density plot
Density plots of log-intensity distribution of each library can be superposed 
on a single graph for a better comparison between libraries and for 
identification of libraries with weird distribution. 
```{r density_plots}
# set graphical parameter
par(mfrow = c(1,3))

# Normalize data for library size and expression intesntiy
log2cpm.tech <- edgeR::cpm(dge, log = TRUE)
log2cpm.filtered <- edgeR::cpm(dge.filtered, log = TRUE)
log2cpm.norm <- edgeR::cpm(dge.filtered.norm, log = TRUE)

# set colors
colors <- colorbindColors
nsamples <- ncol(dge)

# First, plot the first column of the log2cpm.tech density
plot(density(log2cpm.tech[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "A. Raw", xlab = expression('Log'[2]~CPM))

# For each sample plot the lcpm density
for (i in 2:nsamples){
  den <- density(log2cpm.tech[,i]) #subset each column
  lines(den$x, den$y, col = colors[i], lwd = 2) 
}

# Second, plot log2cpm.filtered
plot(density(log2cpm.filtered[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "B. Filtered", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.filtered[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# Third, plot log2cpm.norm
plot(density(log2cpm.norm[,1]), col = colors[1], lwd = 2, ylim = c(0,0.4), 
     las = 2, main = "C. Normalized", xlab = expression('Log'[2]~CPM))
abline(v = edgeR::cpm(3, log = TRUE), lty = 3)
for (i in 2:nsamples) {
  den <- density(log2cpm.norm[,i])
  lines(den$x, den$y, col = colors[i], lwd = 2)
}

# save
path <- paste0("../../results/", tool, "/library/", comparison, "_gene_density")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```

clean up 
```{r}
remove(
       dge, 
       dge.filtered,
       lcpm,
       log2cpm.filtered,
       log2cpm.norm,
       log2cpm.tech)
```

# Save R object
```{r}
saveRDS(dge.filtered.norm, file = paste0("../../rObjects/", comparison, ".dge.filtered.norm.rds"))
dge.filtered.norm <- readRDS(paste0("../../rObjects/", comparison, ".dge.filtered.norm.rds"))
```

# CCA
```{r}
form <- ~ MF.NFT + 
MF.Amyloid + 
MF.SP + 
MF.Tau + 
#MF.LB +
MF.NFT +
Brain.wt + 
Duration + 
Age + 
PMI + 
RIN + 
Braak.NFT + 
Thal.amyloid + 
#Cing.LB + 
#Cing.Synuclein + 
APOE +
#AD.subtype + 
#TDP.type +
VaD +
#MAPT + 
#GRN + 
Race +
#TMEM106b +
Race + 
FHx +
sex_inferred 

C = canCorPairs(form, metadata)
#plotCorrMatrix( C )

cor.mtest <- function(C, ...) {
    C <- as.matrix(C)
    n <- ncol(C)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(C[, i], C[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(C)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(C)
col <- colorRampPalette(c("#4477AA", "#77AADD", "#FFFFFF", "#EE9988", "#BB4444"))
  corrplot(C, method="color", col=col(200),  
         type="upper", order="hclust", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col="black", tl.srt=45, #Text label color and rotation
         diag=FALSE, col.lim = c(0, 1)
         )
  
path <- paste0("../../results/", tool ,"/varpart/", comparison, "_gene_CCA")
saveToPDF(paste0(path, ".pdf"), width = 16, height = 16)

```
### re-examine CCA 
subset of the metadata variables
```{r, eval = FALSE}
form <- ~ TYPE + 
  sex_inferred + 
  VaD + 
  Race + 
  APOE + 
  FHx + 
  Age + 
  MF.SP + 
  MF.NFT + 
  MF.Amyloid +
  RIN + 
  Braak.NFT + 
  Brain.wt 
C = canCorPairs( form, metadata)
# Plot correlation matrix
#adjust plot margins
plotCorrMatrix( C )
#path <- paste0("../../results/", tool ,"/varpart/", comparison, "_CCA_limited_form")
#saveToPDF(paste0(path, ".pdf"), width = 16, height = 16)
```

# Design matrix
```{r design_matrix}
dge.filtered.norm$samples$RIN[is.na(dge.filtered.norm$samples$RIN)] <- 1

design <- model.matrix(~ 0 + TYPE + RIN + Age + sex_inferred + Race,  dge.filtered.norm$samples)
colnames(design) <- c(CONTROL, AD, PA, LBD, "RIN", "Age", "sex", "Hispanic", "Native_American")
```

# Voom
```{r voom}
# voom transform counts
#v <- voomWithQualityWeights(dge.filtered.norm,
#                            design,
#                            plot = FALSE)

# no weights needed with this large sample size
v <- voom(dge.filtered.norm, design, plot=TRUE)
path <- paste0("../../results/", tool, "/voom/", comparison, "_gene_mean_voom")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```
# PCA on all/the most variable genes
Select most variable genes based on the biological 
coefficient of variance
```{r pca, cache=TRUE}
# Voom transformed counts
voomCounts <- v$E
voomCountsMatrix <- data.matrix(voomCounts, rownames.force = NA)
# Setting the N of genes to use
ntop = length(dge.filtered.norm$genes$gene_id)
# Sorting by the coefficient of variance
means <- rowMeans(voomCountsMatrix)
Pvars <- rowVars(voomCountsMatrix)
cv2 <- Pvars / means ^ 2
select <-
  order(cv2, decreasing = TRUE)[seq_len(min(ntop, length(cv2)))]
head(select)
highly_variable_exp <- ((voomCountsMatrix)[select,])
dim(highly_variable_exp)
# Running PCA
pca_exp <- prcomp(t(highly_variable_exp), scale = F, center = T)
# scale a logical value indicating whether the variables should be scaled
# to have unit variance before the analysis takes place.
# a logical value indicating whether the variables should be shifted to be zero centered.
head(pca_exp$x)[, 1:3]
summary(pca_exp)
# Dataframe with the first 10 PCs
dim1_10 <- data.frame(pca_exp$x[, 1:10])
# Adding metadata
pcaWithMetadata <- merge(dim1_10, dge.filtered.norm$samples, by = 0, all = TRUE)
pcaWithMetadata$group <- factor(pcaWithMetadata$TYPE,
                                 levels = c(CONTROL, AD, PA, LBD, NA))
# Plotting
ggplot(data = pcaWithMetadata, aes(
  x = PC1,
  y = PC2,
  shape = group,
  color = group
)) +
  geom_point(size = 2) +
  theme_bw() +
#  xlim(-150, 150) +
#  ylim(-150, 150) +
  scale_color_manual(values = c(control_color, AD_color,
                                PA_color, LBD_color,
                                "azure3")) +
  scale_shape_manual(values = c(control_shape, AD_shape,
                                PA_shape, LBD_shape)) +
  theme(
    plot.title = element_text(size = 7, face = "bold"),
    legend.title = element_text(size = 7),
    legend.text = element_text(size = 6),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6),
    axis.title.x = element_text(size = 6),
    axis.title.y = element_text(size = 6)
  ) +
  theme(legend.title = element_blank()) +
  xlab("PC1 ") +
  ylab("PC2 ")
```
lmFit computes coefficients, residual variances and standard errors. Note that in the limma manual and in the example above, I am saving the result of contrasts.fit as a separate object (called fit2), this way you still have access to the original lmFit result as well. For your linear model, the leading coefficients correspond to average log-expression values for different conditions
contrasts.fit converts the coefficients and standard errors to reflect the contrasts rather than the original design matrix, but does not compute t-statistics or p-values. As in the Limma manual: “The coefficients, unscaled standard deviations and correlation matrix are re-calculated in terms of the contrasts”
eBayes computes t-statistics and p-values from the coefficients and standard errors. Therefore running eBayes before contrast.fit will give non-sensical results in terms of obtained p-values.
```{r}
# fits linear model for each gene given a series of arrays
fit <- lmFit(v, design)
coef.fit <- fit$coefficients
head(coef.fit)
# contrast design for differential expression
contrasts <- makeContrasts(myContrasts, 
  levels = colnames(design))
head(contrasts)

# save contrast names
allComparisons <- colnames(contrasts)
allComparisons # check

# run contrast analysis
vfit <- contrasts.fit(fit, contrasts = contrasts)

# Compute differential expression based on the empirical Bayes moderation of the
# standard errors towards a common value.
veBayesFit <- eBayes(vfit)
plotSA(veBayesFit, main = "Final Model: Mean-variance Trend")

# save
path <- paste0("../../results/", tool, "/voom/", comparison, "_gene_final_mean_var")
saveToPDF(paste0(path, ".pdf"), width = 6, height = 4)
```

```{r save_EList}
saveRDS(v, file = paste0("../../rObjects/", directory, comparison, ".gene_voom.rds"))
#v <- readRDS(paste0("../../rObjects/", directory, comparison, ".gene_voom.rds"))
saveRDS(voomCountsMatrix, file = paste0("../../rObjects/", directory, comparison, ".voomCountsMatrix.rds"))
```

# Number of DEGs
Identify number of differential expressed genes.
```{r decide_tests}
pval <- 0.05

sumTable <- 
  summary(decideTests(
    vfit,  
    adjust.method = "BH", 
    p.value = pval,
    lfc = 0  
  ))

print(paste0(" FDRq < ", pval))
sumTable
```

# Output DEG tables
```{r output_DEG_tables}
coef <- 1
allComparisons <- c(comparison)
for (i in allComparisons) {
  # p < 1, log2fc > 0 
  vTopTableAll <-
    topTable(
      veBayesFit, 
      coef = coef,  
      n = Inf, 
      p.value = 1,
      lfc = 0 
    )
vTopTableAll <-
  subset(
    vTopTableAll,
    select = -c(
      score,
      phase,
      transcript_id,
      transcript_type,
      transcript_name,
      transcript_support_level,
      exon_number,
      exon_id,
      ont,
      protein_id,
      ccdsid
    )
  )
    saveRDS(vTopTableAll, file = 
            paste0("../../rObjects/", 
                   i, ".genetable.rds"))
  path <- paste0("../../results/", tool, "/DEGs/",
  i, "_gene_DEGs_FDRq1.00.txt", sep = "") 
  write.table(
    vTopTableAll,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # p < 0.05, log2fc > 0
  vTopTable1 <-
    topTable( 
      veBayesFit,  
      coef = coef,  
      n = Inf, 
      p.value = 0.05,
      lfc = 0
    )
  path <- paste0("../../results/", tool, "/DEGs/",
  i, "_gene_DEGs_FDRq0.05.txt", sep = "") 
  write.table(
    vTopTable1,
    path,
    sep = "\t",
    row.names = FALSE,
    quote = FALSE
  )
  # increment 
  coef <- coef + 1
}
remove(coef)
```

Read table with all genes (FDRq = 1).
```{r read_DEG_table}
coef <- 1

for (i in allComparisons) {
  filepath <- paste0(
    "../../results/",
    tool,
    "/DEGs/",
    i, 
    "_gene_DEGs_FDRq1.00.txt"
  )
  assign(i,
         read.delim(
           filepath,
           header = TRUE,
           sep = "\t",
           stringsAsFactors = FALSE
         ))
  # increment
  coef <- coef + 1
}
```

# Assign colors
Assign colors  values based on FDRq cutoff of 0.05.
```{r assign_colors}
dge_comparison <- read.delim(paste0(
    "../../results/",
    tool,
    "/DEGs/",
    comparison, 
    "_gene_DEGs_FDRq1.00.txt"), 
    sep = "\t", 
    header = TRUE)
color_values <- vector()
max <- nrow(dge_comparison)

for(i in 1:max){
  if (dge_comparison$adj.P.Val[i] < 0.05){
    if (dge_comparison$logFC[i] > 0){
      color_values <- c(color_values, 1) # 1 when logFC > 0 and FDRq < 0.05
    }
    else if (dge_comparison$logFC[i] < 0){
      color_values <- c(color_values, 2) # 2 when logFC < 0 and FDRq < 0.05
    }
  }
  else{
    color_values <- c(color_values, 3) # 3 when FDRq >= 0.05
  }
}

dge_comparison$color_p0.05 <- factor(color_values)
```

# Subset genes to label
Subset the top 10 up and down-regulated genes
```{r}
up <- dge_comparison[dge_comparison$color_p0.05 == 1,]
up10 <- up[1:10,]

down <- dge_comparison[dge_comparison$color_p0.05 == 2,]
down10 <- down[1:10,]
```

# Volcano plot
```{r volcano}
hadjpval <- (-log10(max(
  dge_comparison$P.Value[dge_comparison$adj.P.Val < 0.05], 
  na.rm=TRUE)))

p_vol <-
  ggplot(data = dge_comparison, 
         aes(x = logFC,  
             y = -log10(P.Value), 
             color = color_p0.05)) +  
  geom_point(alpha = 1.5, size = 1.7) +  
  theme_bw() + 
  theme(legend.position = "none") +  
  scale_color_manual(values = c("red", "blue","grey")) +  
  labs(
    title = "", # no main title
    x = expression(log[2](FC)), 
    y = expression(-log[10] ~ "(" ~ italic("p") ~ "-value)") 
  ) +
  theme(axis.title.x = element_text(size = 10),
        axis.text.x = element_text(size = 10)) +
  theme(axis.title.y = element_text(size = 10),
        axis.text.y = element_text(size = 10)) +
  geom_hline(yintercept = hadjpval,  #  horizontal line
                     colour = "#000000",
                     linetype = "dashed") +
  ggtitle(paste0(condition, " vs Control\nAdj.P.value < 0.05")) +
  theme(plot.title = element_text(size = 10)) +
  geom_text_repel(data = up10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "maroon", 
                  fontface="italic",
                  size = 3, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 30)
                  ) +
  geom_text_repel(data = down10,
                  aes(x = logFC, y= -log10(P.Value), label = gene_name), 
                  color = "navyblue", 
                  fontface="italic",
                  size = 3, 
                  max.overlaps = getOption("ggrepel.max.overlaps", default = 50)
                  )  +
  scale_y_continuous(breaks = seq(0,10,by=1), limits = c(0,10)) +
  scale_x_continuous(breaks = seq(-2,3,by=1), limits = c(-2,2))
p_vol

# save
path <- paste0("../../results/", tool, "/volcano/", comparison,"_gene_volcano_FDRq0.05")
saveToPDF(paste0(path, ".pdf"), width = 5.2, height = 5.2)
```

```{r}
glimmaVolcano(veBayesFit, coef = 1,  dge = dge.filtered.norm, groups = dge.filtered.norm$samples$TYPE, display.columns=c("gene_name", "AdjPValue", "seqnames"))
```

# Heatmap 
```{r}
library(gplots)
basal.vs.lp.topgenes <- dge_comparison$gene_name[1:100]
i <- which(v$genes$gene_name %in% basal.vs.lp.topgenes)
mycol <- colorpanel(1000,"blue","white","red")
heatmap.2(v$E[i,], scale="row",
   labRow=v$genes$gene_name[i], labCol=v$targets$TYPE, 
   col=mycol, trace="none", density.info="none", 
   margin=c(8,6), lhei=c(2,10), dendrogram="column")

path <- paste0("../../results/", tool, "/heatmap/", comparison,"_gene_volcano_FDRq0.05")
saveToPDF(paste0(path, ".pdf"), width = 12, height = 8)

```

