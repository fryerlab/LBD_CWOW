---
title: "WGCNA"
author: "Kimberly Olney, Ph.D."
date: "03/31/2023"
output:
  html_document:
    df_print: paged
  pdf_document: default
params:
  args: myarg
---
Consensus network analysis on LBD CWOW female and male data. 

Tutorials: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/index.html 
Background and glossary information https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Simulated-00-Background.pdf 

Overview of steps:
1) data input
2) network construction
  2.A) Relate consensus modules to modules in individual sets. 
  2.B) Relate modules to external trains (brain weight, age, ect.)
3) relating modules and genes to external information 

# Setup
```{r setup}
knitr::opts_knit$set(root.dir = ".")
```
# Install
GO enrichment calculations in WGCNA are deprecated recommended to use the R package anRichment which provides replacement for WGCNA functions GOenrichmentAnalysis() and userListEnrichment(). We will also use gprofiler. 
```{r install eval=FALSE}
BiocManager::install("WGCNA")
source("https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/GeneAnnotation/installAnRichment.R")
installAnRichment()
install.packages(c("AnnotationDBI", "GO.db", "org.Hs.eg.db", "org.Mm.eg.db", "TxDb.Hsapiens.UCSC.hg19.knownGene", "TxDb.Mmusculus.UCSC.mm10.knownGene"))
remotes::install_github("kevinblighe/CorLevelPlot")
```
# Libaries
```{r library message=FALSE}
library(WGCNA)
library(anRichmentMethods)
library(tidyverse)
library(CorLevelPlot)
library(gridExtra)
```
# User defined variables
```{r set_variables, warning=FALSE, message=FALSE}
source(here::here("/research/labs/neurology/fryer/m239830/LBD_CWOW/scripts/R", "file_paths_and_colours.R"))
source(here::here("/research/labs/neurology/fryer/m239830/LBD_CWOW/scripts/R", "gtf_path.R"))
condition <- c("TYPE.SEX") 
tool <- c("star")
```
# Read in DGE object & metadata
```{r dge}
dge.filtered.norm <- readRDS(paste0("../../rObjects/dge.filtered.norm.rds"))
dim(dge.filtered.norm)
# some samples are missing RIN values. 
# Replace NA with median RIN. 
# This is necessary to be able include RIN as a covariate in voom
# fill missing values with median
dge.filtered.norm$samples$RIN <- impute(dge.filtered.norm$samples$RIN, median)
# one sample is missing VaD information
dge.filtered.norm$samples$VaD <- impute(dge.filtered.norm$samples$VaD, median)
dge.filtered.norm$samples$flowcell_and_lane <- factor(dge.filtered.norm$samples$flowcell_and_lane)
dge.filtered.norm$samples$APOE <- factor(dge.filtered.norm$samples$APOE)

info <- as.data.frame(dge.filtered.norm$samples)
genes <- dge.filtered.norm$genes
```
# lcpm data 
```{r genes_lcpm}
lcpm <- edgeR::cpm(dge.filtered.norm$counts, log = TRUE) # obtain log CPM counts
```
# Add biomarker expression to dge metadata 
```{r biomarker_expression}
biomarkers <- c("ENO2", "GFAP", "OLIG2", "CD34", "P2RY12")

for (i in biomarkers) {
  biomarker <- subset(genes, gene_name == i) # gene of interest 
  biomarker_counts <- subset(lcpm, rownames(lcpm) %in% biomarker)
  biomarker_melt <- reshape2::melt(biomarker_counts) # reshape data 
  # rename columns to merge with metadata 
  names(biomarker_melt)[names(biomarker_melt) == "value"] <- i 
  # rename columns to merge with metadata 
  names(biomarker_melt)[names(biomarker_melt) == "Var2"] <- "NPID" 
  names(biomarker_melt)[names(biomarker_melt) == "Var1"] <- "gene_id"
  biomarker_melt$gene_id <- NULL
  assign(paste0(i),biomarker_melt)
}

# add gene expression values into one data frame 
# put all data frames into a list
df_list <- list(ENO2, OLIG2, CD34, P2RY12, GFAP)

# merge all data frames in list
cell_biomarker_lcpm <- df_list %>% reduce(full_join, by='NPID')
```
# Scale data
rescaling a predictor in a regression has absolutely no effect on the magnitude of the relation being studied—the slope itself will not change its steepness, nor will the p-values or variance explained be changed. Re-scaling is merely a means of communicating the nature of the regression line in different, hopefully more intuitive language.
```{r scale}
# New df with cell type biomarker expression and sample metadata 
df <- merge(cell_biomarker_lcpm, info, by = "NPID")
# scale data 
scaled.info <-
  df[c(
    "Race_numeric",
    "RIN",
    "Age",
    "PCT_CODING_BASES",
    "PCT_INTERGENIC_BASES",
    "PCT_INTRONIC_BASES",
    "APOE_E4_allele_count", 
    "ENO2", 
    "GFAP", 
    "OLIG2", 
    "CD34", 
    "P2RY12",
    "Brain.wt"
  )] %>% scale()
scaled.info.df <- as.data.frame(scaled.info)
# remove columns with unscaled data 
df <- (subset(df, select = -c(Race_numeric, RIN, Age, PCT_CODING_BASES, PCT_INTRONIC_BASES, APOE_E4_allele_count, ENO2, GFAP, OLIG2, CD34, P2RY12, Brain.wt)))
# Add scaled information to the metadata called "info"
info_with_scale <- cbind(df, scaled.info.df)
```
# replace sample information with scaled sample information
```{r replace_info}
all.equal(dge.filtered.norm$samples$NPID, as.character(info_with_scale$NPID))
# replace sample information with the updated info that includes biomakrer expression
dge.filtered.norm$samples <- info_with_scale
```
# Voom transform counts 
```{r voom, warning=FALSE}
formula <- (~ 0 + TYPE)
voom_with_weights <-
  variancePartition::voomWithDreamWeights(
    counts = dge.filtered.norm$counts,
    formula = formula,
    data = dge.filtered.norm$samples,
    BPPARAM = BiocParallel::SnowParam(cores),
    plot = FALSE
  )
voomCounts <- voom_with_weights$E
```
# Counts
The voom method (Law et al., 2014) stabilizes variance of RNA-seq data. It does so by identifying the mean–variance relationship of the data at the gene-level.
WGCNA reads as input counts data that is stabilized. 
```{r counts}
# transpose data to be in the correct format for WGCNA 
counts <- t(voomCounts)
```
# Data traits
```{r data_traits}
dim(counts)
dim(info)
# keep only the columns that hold information we need. 
dataTraits <- info[, c(6,11:19,21,22,24,29,37,108,109,114,117:124)] # Keep
dim(dataTraits)
# disease type isn't numeric, make numeric as this is required down stream
numeric_traits <- sapply(dataTraits, as.numeric)
numeric_traits <- as.data.frame(numeric_traits) # save as data frame
rownames(numeric_traits) <- rownames(dataTraits) # add NPID as row names
```
# check data
```{r check_dfs}
all.equal(info$NPID, rownames(counts))
all.equal(info$NPID, colnames(lcpm))
```
# Split by sex 
Each row corresponds to a gene and column to a sample or auxiliary information. We now remove the auxiliary data and put the expression data into a multi-set format suitable for consensus analysis.
```{r split_sex}
# Split by sex 
female_NPID <- subset(metadata, sex_inferred == "female")
male_NPID <- subset(metadata, sex_inferred == "male")
# extracting data frame rows
female <- counts[rownames(counts) %in% female_NPID$NPID, ] 
male <- counts[rownames(counts) %in% male_NPID$NPID, ] 

all.equal(colnames(male), colnames(female))
# We work with two sets:
nSets <- 2
# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels = c("Female", "Male")
shortLabels = c("Female", "Male")
# Form multi-set expression data: columns starting from 9 contain actual expression data.
multiExpr = vector(mode = "list", length = nSets)
multiExpr[[1]] <- list(data = as.data.frame(female))
names(multiExpr[[1]]$data) <- colnames(female)
multiExpr[[2]] <- list(data = as.data.frame(male))
names(multiExpr[[2]]$data) <- colnames(male)
# Check that the data has the correct format for many functions operating on multiple sets
exprSize <- checkSets(multiExpr)
exprSize
```
# Data traits
```{r data_traits}
dim(info)
# keep only the columns that hold information we need. 
dataTraits <- info[, c(6,11:19,21,22,24,29,37,108,109,114,117:124)] # Keep
dim(dataTraits)
# disease type isn't numeric, make numeric as this is required down stream
numeric_traits <- sapply(dataTraits, as.numeric)
numeric_traits <- as.data.frame(numeric_traits) # save as data frame
rownames(numeric_traits) <- rownames(dataTraits) # add NPID as row names
```

# Data cleaning 
# QC - outlier detection
goodSamplesGenes - This function checks data for missing entries, entries with weights below a threshold, and zero-variance genes, and returns a list of samples and genes that pass criteria on maximum number of missing or low weight values. If necessary, the filtering is iterated.
```{r QC_outliers}
# females
gsg <- goodSamplesGenes(multiExpr[[1]]$data)
summary(gsg)

table(gsg$goodGenes) # outlier genes
table(gsg$goodSamples) # outlier samples
# no outliers

# males
gsg <- goodSamplesGenes(multiExpr[[2]]$data)
summary(gsg)

table(gsg$goodGenes) # outlier genes
table(gsg$goodSamples) # outlier samples
# no outliers
```
# Euclidean distance for each sex separately
```{r euc_dis}
sampleTrees = list()
for (set in 1:nSets)
{
  sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
}
```
# View trees 
```{r tree}
pdf(file = "../../results/star/WGCNA/sex_specific_euclidean_distance.pdf", width = 12, height = 12);
par(mfrow=c(2,1))
par(mar = c(0, 4, 2, 0))
for (set in 1:nSets)
  plot(sampleTrees[[set]], main = paste("Sample clustering on all genes in", setLabels[set]),
      xlab="", sub="", cex = 0.7);
dev.off();
```
# Add metadata to multiExpr 
```{r add_meta}
# Form a multi-set structure that will hold the clinical traits.
Traits = vector(mode="list", length = nSets);
for (set in 1:nSets)
{
  setSamples = rownames(multiExpr[[set]]$data);
  traitRows = match(setSamples, rownames(dataTraits));
  Traits[[set]] = list(data = dataTraits[traitRows, -1]);
}
collectGarbage();
# Define data set dimensions
nGenes = exprSize$nGenes;
nSamples = exprSize$nSamples;
```
# Save expression data with the metadata
```{r save_obj}
save(multiExpr, Traits, nGenes, nSamples, setLabels, shortLabels, exprSize,
    file = "../../rObjects/Consensus-dataInput.RData");
```
# Network construction 
```{r eval=FALSE}
# load data
lnames <- load(file = "../../rObjects/Consensus-dataInput.RData")
# The variable lnames contains the names of loaded variables.
lnames
# Get the number of sets in the multiExpr structure.
nSets = checkSets(multiExpr)$nSets
```
Among other variables we have loaded the variables multiExpr and Traits containing the expression and trait
data, respectively. Further, expression data dimensions are stored in nGenes and nSamples.
# Module detection
Atomatic multiple set network construction and detection of consensus modules. We note that while the actual network construction and module detection is executed in a single function call, a preliminary step of choosing a suitable soft-thresholding power must be performed first.

# soft threshold - power
which power gives a scale-free topology 
Analysis of scale free topology for multiple soft thresholding powers. The aim is to help the user pick an appropriate soft-thresholding power for network construction.

networkType - signed, the direction of the gene expression 
```{r soft_thres}
# Choose a set of soft-thresholding powers
powers <- c(seq(1,10,by=1), seq(12,50, by=2))
# Initialize a list to hold the results of scale-free analysis
powerTables <- vector(mode = "list", length = nSets)
allowWGCNAThreads() # multithreads
# Call the network topology analysis function for each set in turn
for(set in 1:nSets)
  powerTables[[set]] = list(data = pickSoftThreshold(multiExpr[[set]]$data, 
                                   powerVector=powers, networkType = "signed", 
                                   verbose = 5)[[2]])
```
# Plot power 
```{r plot_power}
# Plot the results:
colors = c("black", "red")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "Median connectivity",
"Max connectivity");
# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4);
for (set in 1:nSets)
{
  for (col in 1:length(plotCols))
{
    ylim[1, col] = min(ylim[1, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
    ylim[2, col] = max(ylim[2, col], powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE);
} }
# Plot the quantities in the chosen columns vs. the soft thresholding power
sizeGrWindow(8, 6)
pdf(file = "../../results/star/WGCNA/power_each_sex.pdf", wi = 8, he = 6)
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;
for (col in 1:length(plotCols)) for (set in 1:nSets)
{
if (set==1) {
    plot(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
        xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
        main = colNames[col]);
addGrid(); }
if (col==1) {
    text(powerTables[[set]]$data[,1], -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
        labels=powers,cex=cex1,col=colors[set]);
  } else
    text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
        labels=powers,cex=cex1,col=colors[set]);
  if (col==1)
  {
    legend("bottomright", legend = setLabels, col = colors, pch = 20)
  } else
    legend("topright", legend = setLabels, col = colors, pch = 20)
} 
dev.off()
```
# Pick a power
### female
```{r female_pick_power}
# female
ggplot(powerTables[[1]]$data, aes(Power, SFT.R.sq, label= Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1, label = powerTables[[1]]$data$Power) +
  geom_hline(yintercept = 0.8, color = "red") +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()

ggplot(powerTables[[1]]$data, aes(Power, mean.k., label = Power)) +
  geom_point()+
  geom_text(nudge_y = 10) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()
```
### male 
```{r male_pick_power}
# male
ggplot(powerTables[[2]]$data, aes(Power, SFT.R.sq, label= Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1, label = powerTables[[2]]$data$Power) +
  geom_hline(yintercept = 0.8, color = "red") +
  labs(x = 'Power', y = 'Scale free topology model fit, signed R^2') +
  theme_classic()

ggplot(powerTables[[2]]$data, aes(Power, mean.k., label = Power)) +
  geom_point()+
  geom_text(nudge_y = 10) +
  labs(x = 'Power', y = 'Mean Connectivity') +
  theme_classic()
```
# Bloackwise 
This function performs automatic network construction and module detection on large expression datasets in a block-wise manner.

For each block of genes, the network is constructed and (if requested) topological overlap is calculated. If requested, the topological overlaps are returned as part of the return value list. Genes are then clustered using average linkage hierarchical clustering and modules are identified in the resulting dendrogram by the Dynamic Hybrid tree cut. Found modules are trimmed of genes whose correlation with module eigengene (KME) is less than minKMEtoStay. Modules in which fewer than minCoreKMESize genes have KME higher than minCoreKME are disbanded, i.e., their constituent genes are pronounced unassigned.

correlation type is pearson 
Will define which cor to use. There is cor in stats package that will throw an error if you don't specify that cor should be from the WGCNA package 
deepSplit - integer value between 0 and 4. Provides a simplified control over how sensitive module detection should be to module splitting, with 0 least and 4 most sensitive.
```{r blockwise}
female_counts <- multiExpr[[1]]$data
soft_power <- 14
temp_cor <- cor
cor <- WGCNA::cor 
female_bwnet <- blockwiseModules(female_counts, 
                 maxBlockSize = 15000, # all genes
                 TOMType = "signed", # direction of the gene 
                 power = soft_power, # power decided from step above 
                 mergeCutHeight = 0.25, # height at which to merge modules # 1-0.25 = 0.75 correlation
                 numericLabels = FALSE, 
                 randomSeed = 28, # to get the same results again 
                 verbose = 3
                 )
# save 
save(female_bwnet, file = "../../rObjects/female_XX_bwnet.Rdata")
```

```{r male_blockwise}
male_counts <- multiExpr[[2]]$data
soft_power <- 10
temp_cor <- cor
cor <- WGCNA::cor 
male_bwnet <- blockwiseModules(male_counts, 
                 maxBlockSize = 15000, # all genes
                 TOMType = "signed", # direction of the gene 
                 power = soft_power, # power decided from step above 
                 mergeCutHeight = 0.25, # height at which to merge modules # 1-0.25 = 0.75 correlation
                 numericLabels = FALSE, 
                 randomSeed = 28, # to get the same results again 
                 verbose = 3
                 )
# save 
save(male_bwnet, file = "../../rObjects/male_XY_bwnet.Rdata")
```

# Modules 
```{r modules}
consMEs <- bwnet$MEs
moduleColors <- bwnet$colors
moduleLabels <- bwnet$colors
consTree <- bwnet$dendrograms[[1]];

sizeGrWindow(8,6);
#pdf(file = "Plots/ConsensusDendrogram-auto.pdf", wi = 8, he = 6)
plotDendroAndColors(consTree, moduleColors,
                  "Module colors",
                  dendroLabels = FALSE, hang = 0.03,
                  addGuide = TRUE, guideHang = 0.05,
                  main = "Consensus gene dendrogram and module colors")
dev.off()
save(consMEs, moduleLabels, moduleColors, consTree, file = "../../rObjects/Sex_Consensus-NetworkConstruction-auto.RData")
# dataframe of sample IDs as rows and modeules as columns. The value is the correlation. 
ngenes_per_module <- table(bwnet$colors) # number of genes in each module 
write.table(ngenes_per_module, 
            "../../results/star/WGCNA/Sex_consensus_ngenes_per_module.txt", 
            sep = "\t", quote = FALSE, row.names = FALSE)

```
# Load data
```{r}
load(file = "../../rObjects/male_XY_bwnet.Rdata")
load(file = "../../rObjects/female_XX_bwnet.Rdata")
lnames <- load(file = "../../rObjects/Sex_Consensus-NetworkConstruction-auto.RData")
lnames

femaleLabels <- female_bwnet$colors
femaleColors <- female_bwnet$colors
femaleTree <- female_bwnet$dendrograms
femaleMEs <- orderMEs(female_bwnet$MEs, greyName = "ME0")
```
```{r}
# Isolate the module labels in the order they appear in ordered module eigengenes
femModuleLabels = substring(names(femaleMEs), 3)
consModuleLabels = substring(names(consMEs), 3)
# Numbers of female and consensus modules
nFemMods = length(femModuleLabels)
nConsMods = length(consModuleLabels)
# Initialize tables of p-values and of the corresponding counts
pTable = matrix(0, nrow = nFemMods, ncol = nConsMods);
CountTbl = matrix(0, nrow = nFemMods, ncol = nConsMods);
# Execute all pairwaise comparisons
for (fmod in 1:nFemMods)
  for (cmod in 1:nConsMods)
  {
    femMembers = (femaleColors == femModuleLabels[fmod]);
    consMembers = (moduleColors == consModuleLabels[cmod]);
    pTable[fmod, cmod] = -log10(fisher.test(femMembers, consMembers, alternative = "greater")$p.value);
    CountTbl[fmod, cmod] = sum(femaleColors == femModuleLabels[fmod] & moduleColors ==
                    consModuleLabels[cmod])
}
```
```{r}
#Truncate p values smaller than 10^{-50} to 10^{-50}
pTable[is.infinite(pTable)] = 1.3*max(pTable[is.finite(pTable)]);
pTable[pTable>50 ] = 50 ;
# Marginal counts (really module sizes)
femModTotals = apply(CountTbl, 1, sum)
consModTotals = apply(CountTbl, 2, sum)
# Actual plotting
sizeGrWindow(10,7 );
#pdf(file = "Plots/ConsensusVsFemaleModules.pdf", wi = 10, he = 7);
par(mfrow=c(1,1));
par(cex = 1.0);
par(mar=c(8, 10.4, 8, 8)+0.3);
labeledHeatmap(Matrix = pTable,
             xLabels = paste(" ", consModuleLabels),
             yLabels = paste(" ", femModuleLabels),
             colorLabels = TRUE,
             xSymbols = paste("Cons ", consModuleLabels, ": ", consModTotals, sep=""),
             ySymbols = paste("Fem ", femModuleLabels, ": ", femModTotals, sep=""),
             textMatrix = CountTbl,
             colors = blueWhiteRed(100)[50:100],
             main = "Correspondence of Female set-specific and Female-Male consensus modules",
             cex.text = 1.0, cex.lab = 1.0, setStdMargins = FALSE);

```
# COMPARE MALE VS FEMALE
```{r}
# Create a variable weight that will hold just the body weight of mice in both sets
ATS = vector(mode = "list", length = nSets);
for (set in 1:nSets)
{
ATS[[set]] = list(data = as.data.frame(Traits[[set]]$data$ATS));
names(ATS[[set]]$data) = "ATS"
}
# Recalculate consMEs to give them color names
consMEsC = multiSetMEs(multiExpr, universalColors = moduleColors);
# We add the weight trait to the eigengenes and order them by consesus hierarchical clustering:
MET = consensusOrderMEs(addTraitToMEs(consMEsC, ATS));

sizeGrWindow(8,10);
#pdf(file = "Plots/EigengeneNetworks.pdf", width= 8, height = 10);
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels, marDendro = c(0,2,2,1), marHeatmap = c(3,3,2,1),
zlimPreservation = c(0.5, 1), xLabelsAngle = 90)
```

#-------------------------------------------------
#-------------------------------------------------
#-------------------------------------------------

# Plot dendrogram
This function plots a hierarchical clustering dendrogram and color annotation(s) of objects in the dendrogram underneath.

guideHang - fraction of the dendrogram height to leave between the top end of the guide line and the dendrogram merge height. 
```{r plot_dendrogram}
plotDendroAndColors(bwnet$dendrograms[[1]], cbind(bwnet$unmergedColors, bwnet$colors), 
                    c("unmerged", "merged"), 
                    dendroLabels = FALSE, 
                    addGuide = TRUE, 
                    hang = 0.03,
                    guideHang = 0.05)
path <- paste0("../../results/star/WGCNA/male_XY_module_dendrogram")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 4)
```
# Association between modules and traits
Which modules are associated with our traits

binarizeCategoricalColumns - Given a data frame with (some) categorical columns, this function creates a set of indicator variables for the various possible sets of levels.

includePairwise - logical should pairwise binary indicators be included? For each pair of levels, the indicator is val1 for the lower level (earlier in levelOrder), val2 for the higher level and NA otherwise.
includeLevelVsAll - Logical: should binary indicators for each level be included? The indicator is val2 where x equals the level and val1 otherwise.
minCount - 	Levels of x for which there are fewer than minCount elements will be ignored.
```{r binary_traits}
controlvsdisease <- binarizeCategoricalColumns(dataTraits$TYPE, 
                           includePairwise = TRUE, 
                           includeLevelVsAll = TRUE, 
                           minCount = 1)
# remove data. from column names
names(controlvsdisease) <- gsub(x = names(controlvsdisease), 
                                pattern = "data.", replacement = "")  
traits <- cbind(numeric_traits, controlvsdisease) # column combine with dataTraits
# disease type isn't numeric, make numeric as this is required down stream
numeric_traits <- sapply(traits, as.numeric) # make sure all are numeric 
numeric_traits <- as.data.frame(numeric_traits) # save as data frame
rownames(numeric_traits) <- rownames(dataTraits) # add NPID as row names
```
# Correlation
```{r correlation}
nSamples <- nrow(counts) # number of samples
nGenes <- ncol(counts) # number of genes

# correlation between modules and traits 
module_trait_corr <- cor(module_eigengenes, numeric_traits, use = 'p')
# get the pval
# Calculates Student asymptotic p-value for given correlations.
module_trait_corr_pval <- corPvalueStudent(module_trait_corr, nSamples)
```
# Heatmap
```{r heatmap}
heatmap.data <- merge(module_eigengenes, numeric_traits, by = "row.names")
heatmap.data <- heatmap.data %>%
  column_to_rownames(var = 'Row.names')

# some data has missing values with na, such as lewy body count. 
# Replace na with zero 
heatmap.data["Cing.LB"][is.na(heatmap.data["Cing.LB"])] <- 0
heatmap.data["Cing.Synuclein"][is.na(heatmap.data["Cing.Synuclein"])] <- 0

CorLevelPlot(heatmap.data, 
             x = names(heatmap.data)[49:51], # which traits
             y = names(heatmap.data)[1:22], # gene modules 
             col = c("blue1", "skyblue", "white", "pink", "red")) # color scale
path <- paste0("../../results/star/WGCNA/male_XY_disease_vs_control_cor_module_heatmap")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 5)
```
# Genes in modules 
```{r genes_modules}
# data frame of module genes
module.gene.mapping <- as.data.frame(bwnet$colors)
module_colors <- c(unique(bwnet$colors))

for (i in module_colors){
  color <- module.gene.mapping %>%
    filter(bwnet$colors == i) %>%
    rownames()
  color <- as.data.frame(color)
  colnames(color)[1] ="gene_id"
  color_genes <- merge(color, genes, by = "gene_id")
  color_genes
  color_genes <- color_genes[, c(1:5,12)] # Keep
  write.table(color_genes, paste0("../../results/star/WGCNA/male_XY_", i, ".txt"), 
              row.names = FALSE, quote = FALSE, sep = "\t")
}
# save into one excel table
# first read in the files
for (i in module_colors) {
  filepath <- paste0("../../results/star/WGCNA/male_XY_", i,".txt"
  )
  assign(paste0(i),
         read.delim(
           filepath,
           header = TRUE,
           sep = "\t",
           stringsAsFactors = FALSE
         ))
}
module_colors
list_of_datasets <- list("grey" = grey,
"blue" = blue,
"yellow" = yellow,
"turquoise" = turquoise,
"brown" = brown,
"red" = red,
"greenyellow" = greenyellow,
"magenta" = magenta,
"tan" = tan,
"green" = green,
"black" = black,
"pink" = pink,
"purple" = purple,
"salmon" = salmon,
"cyan" = cyan, 
"darkred" = darkred, 
"lightcyan" = lightcyan,
"lightyellow" = lightyellow, 
"grey60" = grey60, 
"midnightblue" = midnightblue, 
"royalblue" = royalblue, 
"lightgreen" = lightgreen)
write.xlsx(list_of_datasets, file = paste0(
    "../../results/star/WGCNA/male_XY_genes_in_color_modules.xlsx"))
```
# Sample dendrogram & trait heatmap
Convert traits to a color representation:
The function creates a color represenation for the given numeric input.
signed, the default setting is to use to use a palette that starts with green for the most negative values, continues with white for values around zero and turns red for positive values.
```{r heatmap_traits}
traitColors <- numbers2colors(numeric_traits)
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(htree,
                    traitColors,
                    groupLabels = names(numeric_traits),
                    main = "Sample dendrogram and trait heatmap")
path <- paste0("../../results/star/WGCNA/male_XY_sample_dendrogram_and_trait_heatmap")
saveToPDF(paste0(path, ".pdf"), width = 8, height = 8)
```
# Membership intramodule connectivity
```{r}
module_membership_measure <- cor(module_eigengenes, counts, use = 'p')
module_membership_measure_pval <- corPvalueStudent(module_membership_measure, nSamples)

# high membership genes 
module_membership_measure_pval[1:10,1:10]

# calculate the gene significance and associated p-values
gene_sig_cor <- cor(counts, numeric_traits$LBD.vs.CONTROL, use = 'p')
nLBD_control <- subset(numeric_traits, TYPE == "4" | TYPE == "1")
nLBD_control <- nrow(nLBD_control) 
gene_sig_cor_pval <- corPvalueStudent(gene_sig_cor, nSamples = nLBD_control)

gene_sig_cor_pval %>%
  as.data.frame() %>%
  head(24)
```
# Hubs
```{r}
remotes::install_github("jtlovell/limmaDE2")
library(limmaDE2)
#module.gene.mapping <- as.data.frame(bwnet$colors)
#module_colors <- c(unique(bwnet$colors))

graph<-wgcna2igraph(net = bwnet, datExpr = counts,
                    modules2plot = c(module_colors),
                    colors2plot = c(module_colors),
                    kME.threshold = 0.5, adjacency.threshold = 0.1,
                    adj.power = pow, verbose = T,
                    node.size = 0, frame.color = NA, node.color = NA,
                    edge.alpha = .5, edge.width =1)
plot(graph)


colorh = labels2colors(dat1$allLabels)
hubs <- chooseTopHubInEachModule(counts, module_colors)
hubs
```